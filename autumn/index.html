<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
<title>Magistracy
</title>
<style type="text/css">
div.framed {
    border: solid; border-width: thin;
    border-color: red;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
    width: 90%;
}
div.display {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
    margin-left: 2em;
}
div.inactive {
    margin-left: 10%;
    background: #dd;
    color: #999;
}
</style>
</head>
<body bgcolor="#369FFF">
<table width="800" align="center" border="0" bgcolor="white" cellpadding="16">
<tr><td>

<center>
<h2>
Магистратура мехмата<br/>
Специальный компьютерный практикум
</h2>
</center>

<p>
Самостоятельная работа состоит в решении задач по темам,
которые обсуждаются в лекциях.
По каждой теме нужно решить одну задачу из предлагаемого списка.
Номер задачи равен номеру студента в журнале по модулю <i>n</i>,
где <i>n</i> &mdash; число задач по данной теме.
Решения задач присылайте мне на электронную почту в виде одного или
нескольких файлов, присоединенных к письму (если файлов много,
то лучше присылать zip-архив с файлами в поддиректории).
Адрес моей электронной почты:<br/>
<b>vladimir_borisen (собака) mail.ru</b><br/>
Тема письма должна начинаться со слова "Магистратура".
</p>

<p>
<font color="blue">
Для дистанционных занятий можно использовать Zoom.
Ссылка на конференцию:<br/>
<a href="https://us05web.zoom.us/j/2842740990?pwd=bkhtRlNxL3E3SnZCTU1oSFNHcHJNQT09">https://us05web.zoom.us/j/2842740990?pwd=bkhtRlNxL3E3SnZCTU1oSFNHcHJNQT09</a><br/>
Passcode: 1
</p>

<h4>
Записи лекций прошлых лет:<br/>
&nbsp;&nbsp;<a href="Drafts_Sem1_2021-22.html">осенний семестр 2021</a><br/>
&nbsp;&nbsp;<a href="Drafts_Sem2_2022.html">весенний семестр 2022</a>
</h4>

<hr/>

<ul>
    <h3>
    <a href="#Sem1_2020">Осенний семестр</a>
    </h3>
    <ul>
    <li>
        <a href="MagList2024-25.html">Журнал группы магистратуры 1 курса,
        осенний семестр 2024-25 г.</a>
    </li>
    <li>
        <a href="Drafts_Sem1_2021-22.html">Записи лекций прошлого
        года в текстовом
        файле</a> ("виртуальная доска").
    </li>
    <li>
        <a href="MagList2023-24.html" style="color:gray;">
        Журнал группы магистратуры 1 курса прошлого года,
        осенний семестр 2023-24 г.</a>
    </li>
    </font>
    </ul>

    <h3>
    <a href="#Sem2_2022">Весенний семестр</a>
    </h3>
    <ul>
    <li>
        <a href="Drafts_Sem2_2022.html">Записи лекций в текстовом
        файле</a> прошлого года ("виртуальная доска").
    </li>
    <li>
        <a href="MagList2023-24_Sem2.html">
        Журнал группы магистратуры 1 курса,
        весенний семестр 2024 г.</a>
    </li>
    <li>
        <a href="MagList2022-23_Sem2.html" style="color:gray;">
        Журнал группы магистратуры 1 курса прошлого года,
        весенний семестр 2023 г.</a>
    </li>
    <li>
    <h4>Домашние задания (ссылки)</h4>
    <p>
    По каждой теме надо сделать одну задачу в соответствии
    с номером студента по журналу (номер задачи совпадает с номером студента
    в журнале по модулю <i>m</i>, где <i>m</i> &mdash; число задач в данной
    теме).
    </p>
    <ol>
    <li>
        <a href="#HW_NumberTheory">Задачи на тему "Применение теории
        чисел в криптографии"<a>.
    </li>
    <li>
        <a href="#HW_PythonClasses">Задачи на тему "Классы в Python'е"</a>.
    </li>
    <li>
        <a href="#HW_NumpyMatrices">Задачи на тему "Модуль numpy
        и алгоритмы работы с матрицами в Python'е"</a>.
    </li>
    <li>
        <a href="#HW_LeastSquares">Задача на тему "Линейная регрессия
        и метод наименьших квадратов</a>.
    </li>
    <li>
        <a href="#HW_HuberMAE">Задача на тему "Борьба с выбросами
        в задаче линейной регрессии"</a>: использование функции ошибки Хубера
        и функции средней абсолютной величины ошибки MAE (вместо функции
        квадратичной ошибки MSE), в последнем случае
        с помощью <a href="../MasterAI/index.html#Sem8_2sem">использования 
        методов линейного программирования</a>
        (модуль pulp Питона).
    </li>
    <li>
        <a href="#HW_KernelSVM">Задачи на тему "Модификация
        классического линейного метода опорных векторов"</a> путем
        <i>расширения набора признаков</i> (использование всех
        мономов от исходных признаков степени не выше <i>d</i>)
        или <i>применения ядрового метода опорных векторов</i>.
    </li>
    <li>
        <a href="#HW_SVMClassification">Задачи на тему "Классификация
        рукописных цифр с помощью ядрового метода опорных векторов
        и применения метода главных компонент"</a>.
    </li>
    </ol>
    </li>
    </ul>

    <!--
    <hr/>
    <h3>
    Материалы прошлого учебного года
    </h3>
    <ul>
        <ul>
            <a href="MagList2020-21.html">Журнал группы магистратуры 1 курса,
            осенний семестр 2020 г.</a>
        </ul>
        <ul>
            <a href="MagList2020-21_Sem2.html">Журнал группы магистратуры 1 курса,
            весенний семестр 2021 г.</a>
        </ul>
    </ul>
    -->
</ul>

<!-- --------------------------------------------- -->
<hr/>

<a name="Sem1_2020">
<h2>
Осенний семестр 2024-25
</h2>
</a>

<ul>
<li>
    <a href="Drafts_Sem1_2021-22.html">Записи лекций прошлого года 
    в текстовом файле</a> ("виртуальная доска").
</li>

<li>
    <a href="MagList2024-25.html">Журнал группы магистратуры 1 курса,
    осенний семестр 2024-25 уч. год</a>
</li>
</ul>

<p>
По каждой теме нужно решить одну задачу.
Номер задачи равен номеру студента в журнале по модулю <i>n</i>,
где <i>n</i> &mdash; число задач по данной теме.
Решения задач присылайте мне на электронную почту в виде одного или
нескольких файлов, присоединенных к письму (если файлов много,
то лучше присылать zip-архив с файлами в поддиректории).
В теме письма (поле Subject:) должно быть слово "Магистратура".
Адрес моей электронной почты:<br/>
<b>vladimir_borisen (собака) mail.ru</b>
</p>

<hr/>

<h2>Классы в С++</h3>

<h3>
Трехмерная графика и аналитическая геометрия
</h3>

<h4>
Классы для поддержки двумерной и трехмерной графики
</h4>

<p>
<b>Лекция 4 сентября 2020.</b> 
Классы для поддержки двумерной и трехмерной графики и решение
с их помощью геометрических задач.
<a href="https://vimeo.com/454912785">Видео</a>.
</p>

<p>
Для вычислений на плоскости <b>R</b><sup>2</sup>
используются классы R2Vector (вектор на плоскости с вещественными
координатами) и R2Point (точка на плоскости).
В пакете "<a href="R2Graph.zip">R2Graph.zip</a>"
реализованы все основные операции на плоскости
</p>

<p>
Простой пример программы, использующей классы R2Point и R2Vector
и потоковый ввод-вывод в стиле C++: ввести вершины треугольника
и вычислить центр и радиус вписанной окружности. При вычислении
запрещено использовать координаты векторов и точек, следует
пользоваться исключительно методами классов R2Point и R2Vector.
Файл "<a href="CppProjects/inCircle.php">inCircle.cpp</a>".
Программа использует модуль R2Graph, в котором определяются
классы для поддержки геометрии на плоскости:
файлы "<a href="CppProjects/R2Graph.h">R2Graph.h</a>" и
"<a href="CppProjects/R2Graph.cpp">R2Graph.cpp</a>". Архив всех
файлов: "<a href="CppProjects/InCircle.zip">InCircle.zip</a>"
</p>

<h4>Задачи на использование классов в <b>R</b><sup>2</sup>-графике</h4>

<ol>
<li>
    Вычислить центр и радиус окружности, описанной вокруг треугольника.
</li>
<li>
    Вычислить точку пересечения высот треугольника.
</li>
<li>
    Вычислить точку Жергона:<br>
    <img src="GergonePoint.png"><br>
    (это точка пересечения чевиан, проведенных из вершин
    треугольника к точкам касания вписанной окружности).
</li>
</ol>

<h4>
Трехмерная геометрия: координаты на поверхности Земли и на карте
</h4>

<p>
Мы используем классы R3Vector и R3Point, реализующие точки и векторы
трехмерного пространства, для работы с картами земной поверхности.
Координаты на поверхности Земли задаются широтой и долготой в градусах.
Долгота точки &mdash; это угол между плоскостью гринвичского меридиана
и плоскостью меридиана, проходящего через данную точку. Широта &mdash;
это угол между радиус вектором, проведенным из центра Земли в данную точку,
и плоскостью экватора. Эти углы измеряются в градусах. Долгота положительна 
для восточного полушария (и растет по мере продвижения на восток) и 
отрицательна в западном полушарии. Широта положительна в северном полушарии
и отрицательна в южном.
</p>

<p>
Рассмотрим классическую задачу определения расстояния между двумя
точками на поверхности Земли (приблизительно считаем поверхность Земли 
сферой). Самый простой способ ее решения &mdash; это найти угол между
радиус-векторами, проведенными из центра Земли к этим точкам, и умножить 
его на радиус Земли. В классе R3Vector имеется метод angle, возвращающий
угол между векторами, мы им воспользуемся. Все, что нам нужно &mdash;
это реализовать функцию, определяющую радиус-вектор единичной длины,
проведенный из центра Земли в направлении заданной точки.
</p>

<p>
Для представления векторов и точек на поверхности Земли мы используем
декартову систему координат, у которой начало координат расположено
в центре Земли. 
<img src="EarthCoords.png" align="right" />
Ось <i>x</i> направлена из центра в точку перечесения
экватора и гринвичского меридиана, ось <i>z</i> направлена на северный 
полюс, ось <i>y</i> перпендикулярна осям <i>z</i> и <i>x</i> и направлена
на восток.
</p>

<p>
Радиус-вектор единичной длины, направленный из центра земли
в точку с широтой и долготой (<i>lat</i>, <i>lon</i>),
получается из базисного вектора
<i>e<sub>x</sub></i> двумя поворотами: первый поворот на угол <i>lat</i>
выполняеся вокруг оси <i>z</i>, второй поворот на угол <i>lon</i>
выполняется в меридиональной плоскости. 
<img src="RadiusVector.png" align="left" />
После первого поворота
мы получаем вектор
<div class="display">
    <i>v</i><sub>0</sub> = (cos(&phi;), sin(&phi;), 0)
</div>
где &phi; &mdash; долгота <i>lon</i> в радианах. После второго
поворота на угол <i>lat</i> в меридиональной плоскости
координаты <i>x</i> и <i>y</i> вектора <i>v</i><sub>0</sub>
умножаются на cos(&theta;), где &theta; &mdash; широта <i>lat</i> в
радианах, а координата <i>z</i> равна sin(&theta;):
<div class="display">
    <i>v</i><sub>1</sub> = 
        (cos(&phi;)cos(&theta;), sin(&phi;)cos(&theta;), sin(&theta;))
</div>
Вот реализация функции radiusVector, вычисляющий радиус вектор
единичный длины, проведенный из центра Земли в точку с координатами
(<i>lat</i>, <i>lon</i>) &mdash; широтой и долготой в градусах:
</p>
<pre>
R3Vector radiusVector(double lat, double lon) {
    double phi = lon*PI/180.;   // Convert to radians
    double theta = lat*PI/180.;
    
    // Rotate ex around ez by angle phi: v0 = (cos(phi), sin(phi), 0.)
    // Rotate v0 in meridional plane by angle theta:
    // v1 = (cos(phi)*cos(theta), sin(phi)*cos(theta), sin(theta))
    double cosTheta = cos(theta);
    return R3Vector(cos(phi)*cosTheta, sin(phi)*cosTheta, sin(theta));
}
</pre>
(здесь используется константа PI = &pi;, определенная ранее в тексте).
</p>

<p>
Полный текст программы:
<a href="earthdist.cpp">"earthdist.cpp"</a>.
Проект использует также файлы 
<a href="R3Graph.h">"R3Graph.h"</a> и
<a href="R3Graph.cpp">"R3Graph.cpp"</a>, команда для компиляции
проекта в Linux'е:
<pre>
    g++ -o earthdist earthdist.cpp R3Graph.cpp
</pre>
Архив всех файлов:
<a href="earthdist.zip">"earthdist.zip"</a>.
</p>

<h4>Задачи на использование классов в <b>R</b><sup>3</sup>-графике</h4>

<table border="0">
<tr>
<td>
<img src="CentralProjection.png"/>
</td>
<td>
Карта представляет собой касательную плоскость к земной сфере.
Положение карты задается координатами ее центра: 
(широта центра, долгота центра). Для представления точек поверхности
сферы на карте используется центральная проекция с центром
в центре земного шара. На карте используется декартова система
координат, в которой ось <i>Y</i> направлена на север (касательная
к меридиану, проходящему через центр карты), ось <i>X</i> перпендикулярна
оси <i>Y</i> и направлена на восток. 
Нужно решить одну из следующих
двух задач (студенты с нечетными номерами решают 1-ю задачу,
с четными &mdash; вторую).
</td>
</table>

<ol>
<li>
    Заданы координаты центра карты (<i>mlat</i>, <i>mlon</i>) и
    координаты точки на земной поверхности (<i>lat</i>, <i>lon</i>)
    в градусах. Получить координаты проекции этой точки на карте
    (<i>x</i>, <i>y</i>) в метрах.
</li>
<li>
    Заданы координаты центра карты (<i>mlat</i>, <i>mlon</i>) и
    координаты точки (<i>x</i>, <i>y</i>) на карте в метрах.
    Получить координаты точки на поверхности Земли
    (<i>lat</i>, <i>lon</i>) в градусах, которая проецируется в
    данную точку на карте.
</li>
</ol>

<h3>
Реализация классов на C++
</h3>

<h4>Примеры классов, реализующих математические объекты</h4>

<ol>
<li>
    Комплексное число: class Complex.
    Файлы "<a href="Complex.h">Complex.h</a>",
    "<a href="Complex.cpp">Complex.cpp</a>",
    тестовая программа
    "<a href="complexTst.cpp">complexTst.cpp</a>".
</li>
<li>
    Элемент кольца вычетов по модулю <i>m</i>: class Zm.
    Файлы "<a href="Zm.h">Zm.h</a>",
    "<a href="Zm.cpp">Zm.cpp</a>",
    тестовая программа
    "<a href="tstZm.cpp">tstZm.cpp</a>".<br/>
    <a href="https://vimeo.com/459495624">Видео лекции 18.09.2020</a>
    (вторая половина).
</li>
<li>
    Матрица над полем вещественых чисел: class Matrix.
    Файлы "<a href="Matrix.h">Matrix.h</a>",
    "<a href="Matrix.cpp">Matrix.cpp</a>",
    тестовая программа
    "<a href="matrixTest.cpp">matrixTest.cpp</a>".
</li>
</ol>

<h3>Задачи по теме "Реализация классов"</h3>

<p>
В каждой задаче надо реализовать класс, представляющий
некоторый математический объект, и написать программу,
использующую этот класс. Например, реализовать класс Complex
и с помощью этого класса написать программу, решающую
кубическое уравнение (используя формулу Кардано или
другую подобную). В простейшем случае надо хотя бы написать
тестирующую программу, создающие объекты и вызывающую 
различные методы класса. Обязательно класс должен быть
описан в отдельном h-файле. Также должен быть cpp-файл,
который реализует сложные (не inline) методы класса.
Например, для класса матриц метод Гаусса приведения матрицы
к ступенчатому виду должен быть реализован в cpp-файле
(ни в коем случае не в h-файле!). Таким образом, проект
должен состоять минимум из трех файлов. Например, тестовый
проект для класса Complex состоит из трех файлов:<br/>
    <a href="Complex.h">Complex.h</a>,
    <a href="Complex.cpp">Complex.cpp</a>,
    <a href="complexTst.cpp">complexTst.cpp</a>.
</p>

<p>
Также надо написать 
<a href="Makefile">Makefile</a>,
Например, для класса Complex можно в Unix'е или в MAC OS-X
использовать файл
<pre>
CC = g++ $(CFALGS)
# For debugging
CFLAGS = -O0 -g

complexTst: Complex.h Complex.cpp complexTst.cpp
        $(CC) -o complexTst complexTst.cpp Complex.cpp

clean:
        rm -f complexTst
</pre>
Архив всех файлов для класса Complex (включая
<a href="Makefile">Makefile</a>):
"<a href="Complex.zip">Complex.zip</a>".
</p>

<h4>Список задач по теме "Реализация классов"</h4>

<ol>
<li>
    Реализовать класс Complex, представляющий комплексные
    числа. При этом требуется использовать внутреннее представление
    комплексных чисел в экспоненциальной форме:<br/>
    <div class="display">
    <i>z</i> = <i>r</i>&middot;<i>e</i><sup><i>i</i><i>&phi;</i></sup>
    </div>
    Воспользовавшись этим классом, написать программу,
    решающую кубическое уравнение с помощью формулы
    Кардано (или чего-то похожего). Описание см. в статье
    <a href="CubicEquation.html">Решение кубического уравнения</a>.
</li>

<li>
    Реализовать класс Polynomial, представляющий многочлен
    произвольной степени с коэффициентами в поле вещественных
    чисел. Должны быть реализованы операции сложения, умножения,
    деления с остатком, вычисление наибольшего общего делителя
    многочленов, производной многочлена, а также вычисление
    многочлена с теми же корнями, свободного от кратных корней, 
    т.е. частного от
    деления многочлена <i>f</i> на gcd(<i>f</i>, <i>f'</i>).
</li>

<li>
    Та же задача, но для многочленов над полем <b>Z</b><sub><i>p</i></sub>.
</li>

<li>
    Реализовать класс "Элементы поля <b>GF</b><sub><i>p</i><sup>2</sup></sub>",
    где <i>p</i> &mdash; простое число. 
    См. статью <a href="GFp2.html">Конструкция конечного поля 
    из <i>p</i><sup>2</sup> элементов</a>.
</li>

<li>
    Реализовать класс "Матрицы порядка <i>m</i>&times;<i>n</i>
    над полем вещественных чисел". Должны быть реализованы операции +, -, *
    над матрицами, приведение матрицы к ступенчатому виду, вычисление ранга,
    а также для квадратной матрицы вычисление определителя и обратной матрицы и
    решение линейной системы с невырожденной матрицей.
</li>

<li>
    Та же задача, но для матриц над полем <b>Z</b><sub><i>p</i>.
</li>
</ol>

<h3>Проект "Стековый калькулятор"</h3>

<p>
Стековый калькулятор &mdash; это калькулятор, память которого представляет 
собой стек. При выполнении любой операции ее аргументы сначала извлекаются
из стека, затем выполняется операция и ее результат добавляется обратно
в стек. Таким образом, агрументы операции должны быть положены в стек
перед ее выполнением. Программа вычисления значения формулы на стековом
калькуляторе соответствует обратной польской записи формулы, в которой
знак операции указывается после ее аргументов. Пример:
<div class="display">
    Обычная запись формулы: 
    (1 + 2/3)*(4 + 56)<br/>
    Ее обратная польская запись:
    1, 2, 3, /, +, 4, 56, +, *
</div>
Заметим, что обратная польская запись 
(RPN &mdash; reverse polish notation) не требует скобок
для указания порядка операций.
</p>

<p>
Обратную запись формул предложил польский математик Ян Лукасиевич,
в его честь она называется польской. Помимо обратной записи, он также
предложил и прямую, в которой знак операции указывается
перед аргументами. Например, та же формула
<div class="display">
    (1 + 2/3)*(4 + 56)<br/>
</div>
в прямой польской записи выглядит так:
<div class="display">
    *, + 1, /, 2, 3, +, 4, 56
</div>
Прямая польская запись также не требует скобок. Если обратную польскую
запись удобно вычислять на стековом калькуляторе, то для вычисление 
значения формулы в прямой польской записи можно использовать
рекурсию.
</p>

<p>
Вернемся к обратной польской записи формулы:
<div class="display">
    1, 2, 3, /, +, 4, 56, +, *
</div>
Изобразим последовательные состояния стека при ее вычислении на
стековом калькуляторе:
<pre>
+---+ | 1 | | 2 | | 3 | / |2/3| + |5/3| | 4 | |56 | + |60 | * |100|
      +---+ | 1 | | 2 |   | 1 |   +---+ |5/3| | 4 |   |5/3|   +---+
            +---+ | 1 |   +---+         +---+ |5/3|   +---+
                  +---+                       +---+
</pre>
Если изначально стек пуст, то по окончании вычисления формулы
глубина стека равна единице, а на вершине стека лежит
значение формулы.
</p>

<p>
Исходный код проекта "Стековый калькулятор":
"<a href="StackCalc.zip">StackCalc.zip</a>".
</p>

<h4>Домашнее задание по проекту "Стековый калькулятор"</h4>

<p>
Студенты с нечетными номерами по журналу делают первую задачу,
с четными &mdash; вторую.
</p>
<ol>
<li>
    Добавьте операцию возведения в степень, которая обозначается
    значком ^ (крышка) или ** (двойная звездочка), а также возможность
    вычисления следующих математических функций:
    <div class="display">
    sin(x), cos(x), exp(x),<br/>
    log(x) (натуральный), log2(x), log10(x),<br/>
    tan(x), atan(x), atan2(y, x),<br/>
    cosh(x), sinh(x), tanh(x),<br/>
    abs(x), min(x, y), max(x, y), pow(x, y),<br/>
    powmod(a, n, m), gcd(m, n), invmod(k, m).<br/>
    </div>
    Последние три функции работают с целыми числами типа long&nbsp;long,
    при снятии аргументов со стека и при добавлении результата в стек
    должно выполняться преобразование типов double &rarr; long&nbsp;long
    или long&nbsp;long &rarr; double.
</li>
<li>
    Воспользовавшись классами R2Vector и R2Point из проекта
    "<a href="R2Graph.zip">R2Graph.zip</a>", добавьте в стековый
    калькулятор следующие команды для решения геометрических задач
    на плоскости:
    <div class="display">
    <table border="0">
    <tr>
    <td>distance</td>       <td>Расстояние между двумя точками</td>
    </tr>
    <tr>
    <td>distanceToLine</td> <td>Расстояние от точки до прямой</td>
    </tr>
    <tr>
    <td>intersectLines</td> <td>Найти точку пересечения двух прямых</td>
    </tr>
    <tr>
    <td>inCircle</td>       <td>Вычислить окружность,
                                вписанную в треугольник</td>
    </tr>
    <tr>
    <td>circumCircle</td>   <td>Вычислить окружность,
                                описанную вокруг треугольника</td>
    </tr>
    </table>
    </div>
    При выполнении команды со стека должны сниматься ее аргументы,
    после необходимых вычислений в стек должны добавляться ее результаты.
    Например, при вычислении расстояния от точки до прямой на стеке должны
    лежать 6 чисел: координаты точки, от которой мы ищем расстояние,
    координаты точки и направляющего вектора, задающих прямую.
    Они извлекаются из стека (с учетом порядка, в котором они добавлялись:
    на вершине стека лежит <i>последний аргумент</i>!), выполняются
    необходимые вычислния, на стек кладется результат &mdash;
    расстояние от точки до прямой (одно число). 

    <p>
    Помимо добавления результата операции в стек, нужно также напечатать
    результат выполнения операции (число, точку или окружность).
    Окружность представляется ее центром и радиусом.
    В этой задаче обязательно надо использовать модуль
    "<a href="R2Graph.zip">R2Graph.zip</a>" и определенные в нем
    классы и функции, <i>решение с непосредственными вычислениями через
    координаты не принимается</i>!
    </p>
</li>
</ol>

<h3>Схема построения цикла с помощью инварианта</h3>

<p>
<b>Лекция 9 октября 2020.</b>
Схема построения цикла с помощью инварианта и ее применение
на примере ряда алгоритмов: алгоритм Евклида вычисления наибольшего
общего делителя двух целых чисел, алгоритм быстрого возведения в степень,
расширенный алгоритм Евклида, вычисление логарифма с заданной точностью.
<a href="https://vimeo.com/466639487">Видео лекции</a>.<br/>
Исходные тексты перечисленных алгоритмов на C++: файл
"<a href="CppProjects/gcd.cpp">gcd.cpp</a>".
</p>

<h3>
Сортировка
</h3>

<p>
Лекция <b><a href="Sorting.pdf">Алгоритмы сортировки</a></b> (презентация)
</p>

<p>
<a href="https://vimeo.com/472921551">Видео лекции 23 октября 2020</a>:
оптимальные алгоритмы сортировки. Сортировка кучей Heap Sort, 
сортировка слиянием Merge Sort (рекурсивная схема реализации).
</p>

<h3>
Задачи по теме "Сортировка"
</h3>

<p>
В каждой задаче надо реализовать один из оптимальных
алгоритмов сортировки, работающих за время 
<i>O</i>(<i>n</i>&nbsp;log&nbsp;<i>n</i>). При этом уже заданы
прототипы функций сортировки, которые надо реализовать.
В качестве образца для первых трех задач дается программа
"<a href="CppProjects/tstSort.cpp">tstSort.cpp</a>", 
в которой реализованы только
функции наивной сортировки (bubbleSort и directSort) и некоторые 
вспомогательные функции (bubbleDown, merge, printArray), 
а сами функции сортировки
оставлены для самостоятельной реализации &mdash; выписаны только прототипы
функций сортировки и реализована тестирующая программа.
Тестирующая программа генерирует случайной массив 
вещественных чисел заданной длины,
печатает исходный массив, затем вызывает одну из функций сортировки
и печатает упорядоченный массив, который получается в результате ее
выполнения.
</p>

<p>
Все функции сортировки могут упорядочивать не весь массив целиком,
а некоторый его сегмент. Сегмент задается двумя итераторами
first и last: итератор first указывает на начало сортируемого
сегмента массива, итератор last &mdash; на элемент, которые следует за
последним элементом сортируемого сегмента. Функции сортировки
должны иметь следующие прототипы:
</p>
<pre>
void heapSort(
    std::vector&lt;double&gt;::iterator first, // Beginning of array segment
    std::vector&lt;double&gt;::iterator last   // After-end of array segment
);

void mergeSortRecursive(
    std::vector&lt;double&gt;::iterator first, // Beginning of array segment
    std::vector&lt;double&gt;::iterator last,  // After-end of array segment
    std::vector&lt;double&gt;* tmpMemory = 0   // Temporary memory to use
);

void mergeSortBottomTop(
    std::vector&lt;double&gt;::iterator first, // Beginning of array segment
    std::vector&lt;double&gt;::iterator last,  // After-end of array segment
    std::vector&lt;double&gt;* tmpMemory = 0   // Temporary memory to use
);

void radixSort(
    std::vector&lt;std::string&gt;::iterator first,
    std::vector&lt;std::string&gt;::iterator last,
    int compareLength = 64
);
</pre>

<p>
В четвертой задаче надо применить алгоритм RadixSort для
сортировки строк ограниченной длины. На вход алгоритму подается
массив строк типа std::string и ограничение compareLength на длину строки
(точнее, строки могут быть длиннее, чем compareLength,
но сравниваются они только по первым compareLength символам).
Строки сравниваются лексикографически по их началам
длины compareLength (значение
по умолчанию 64). Если строка короче, чем compareLength,
то она при сравнении <i>мысленно</i> дополняется пробелами справа.
Отметим, что в стандартной библиотеке
STL языка C++ класс std::string реализует корректно лишь
строки ASCII-символов, для символов Unicode этот класс 
может работать некорректно (в частности, если строка типа 
std::string содержит последовательность байтов, которые кодируют
строку в кодировке UTF-8, то результат побайтового сравнения строк
будет некорректным для символов, не входящих в набор ASCII).
</p>

<h4>
Список задач по теме "Сортировка"
</h4>

<p>
Студент должен решить ту задачу, номер которой совпадает
по модулю 4 с его номером по журналу.
</p>

<ol>
<li>
    Реализовать алгоритм сортировки кучей Heap Sort. Прототип
    функции:
<pre>
void heapSort(
    std::vector&lt;double&gt;::iterator first, // Beginning of array segment
    std::vector&lt;double&gt;::iterator last   // After-end of array segment
);
</pre>
</li>

<li>
    Реализовать алгоритм сортировки слиянием Merge Sort,
    используя рекурсивную схему его реализации.
    Прототип функции:
<pre>
void mergeSortRecursive(
    std::vector&lt;double&gt;::iterator first, // Beginning of array segment
    std::vector&lt;double&gt;::iterator last,  // After-end of array segment
    std::vector&lt;double&gt;* tmpMemory = 0   // Temporary memory to use
);
</pre>
</li>

<li>
    Реализовать алгоритм сортировки слиянием Merge Sort,
    используя восходящую схему его реализации.
    Прототип функции:
<pre>
void mergeSortBottomTop(
    std::vector&lt;double&gt;::iterator first, // Beginning of array segment
    std::vector&lt;double&gt;::iterator last,  // After-end of array segment
    std::vector&lt;double&gt;* tmpMemory = 0   // Temporary memory to use
);
</pre>
</li>

<li>
    Реализовать алгоритм сортировки Radix Sort
    для массива ASCII-строк типа std::string.
    Прототип функции:
<pre>
void radixSort(
    std::vector&lt;std::string&gt;::iterator first,
    std::vector&lt;std::string&gt;::iterator last,
    int compareLength = 64
);
</pre>
    Образец тестирующей программы содержится в файле
    "<a href="CppProjects/radixSort.cpp">radixSort.cpp</a>",
    она содержит код, генерирующий случайные строки,
    функцию наивной сортировки прямым выбором directSort,
    а также прототип функции radixSort. Сама функция
    radixSort в этом файле не реализована, ее нужно
    реализовать самостоятельно.
</pre>
</li>

</ol>

<h3>
Обработка текстов
</h3>

<p>
Функции для работы с символами в кодировке UTF-8:
"<a href="CppProjects/utf8/utf8.h">utf8.h</a>",
"<a href="CppProjects/utf8/utf8.cpp">utf8.cpp</a>".
</p>

<p>
Программа нахождения множества русских слов в тексте:
"<a href="CppProjects/russianWords.cpp">russianWords.cpp</a>".
Для каждого слова определяется количество его вхождений в текст.
В результате печатается список слов, упорядоченных по количеству
вхождений слов в текст, а для слов с одинаковым числом вхождений &mdash;
лексикографически.
</p>

<p>
Программа
"<a href="CppProjects/russianWords.cpp">russianWords.cpp</a>".
использует классы std::map, std::basic_string, std::vector
и алгоритм std::sort
из стандартной библиотеки, а также функции для работы с Unicode-символами
в кодировке UTF8 &mdash; файлы
"<a href="CppProjects/utf8/utf8.h">utf8.h</a>",
"<a href="CppProjects/utf8/utf8.cpp">utf8.cpp</a>".
Архив всех файлов проекта:
"<a href="CppProjects/russianWords.zip">russianWords.zip</a>".
</p>

<h3>
Список задач на тему "Обработка текстов"
</h3>

<ol>
<li>
    Найти и упорядочить множество пар соседних слов в тексте
    на русском языке. Два соседних слова образуют пару, если между ними
    нет знаков препинания и других символов, кроме пробелов, переводов строк
    и дефисов. Пары слов упорядочиваются по количеству вхождений в текст,
    а для пар с равным числом вхождений &mdash; лексикографически.
    Напечатать 500 самых часто встречающихся пар.
</li>

<li>
    Найти и упорядочить множество биграмм в тексте
    и напечатать их список, упорядоченный по частотам вхождения в текст.
    (Нужно напечатать только первые 100 биграмм.)
</li>

<li>
    Реализовать шифр Виженера для текста на русском языке.
    Шифруются только русские слова, все остальные символы, включая
    пробелы и переводы строк, исключаются из зашифрованного текста.
    Ключевая фраза также на русском языке, все прописные буквы
    заменяются строчными. Должны быть реализованы 2 программы:
    шифрование и дешифровка.
</li>
</ol>

<h3>
Программирование в среде Qt
</h3>

<p>
Qt (Quazar Technology) &mdash; самая современная и самая лучшая среда
для разработки C++ приложений. К достоинствам Qt относятся:
</p>

<p>
1) независимость текста программы от компьютера и операционной системы 
&mdash; исходные коды приложения одинаковы в Linux, MS Windows, Mac OS-X,
и любых других современных операционных системах. В Qt можно
создавать программы как для обычных компьютеров (Desktop),
так и для операционных систем мобильных телефонов;
</p>

<p>
2) удобство программирования оконных и параллельных приложений
благодаря удачному механизму сигналов и слотов;
</p>

<p>
3) поддержка огромного набора файловых форматов, сетевых протоколов
и устройств;
</p>

<p>
4) программы на Qt, как правило, намного эффективнее, чем программы,
подготовленные в других средах или на других языках, благодаря тому,
что исполняющая система Qt автоматически учитывает особенности каждого
конкретного компьютера и, к примеру, выбирает самый эффективный метод
реализации графики (как правило, через трехмерный интерфейс, если
в компьютере есть современная графическая карта);
</p>

<p>
5) Qt имеет очень удобную среду разработки qtcreator, которая
позволяет редактировать оконные формы и добавлять обработчики сигналов,
посылаемых управляющими элементами окон; qtcreator синхронно вносит
изменения в h- и cpp-файлы.
</p>

<p>
Qt использует небольшое расширение базового языка C++ &mdash;
добавлены ключевые слова signal, emit, slot, connect. Сигналы посылаются,
например, управляющими элементами окон
(для посылки сигнала используется ключевое слово emit).
Слоты &mdash; это методы,
предназначенныедля приема и обработки сигналов. С помощью вызова
connect можно связать сигнал, посылаемый некоторым объектом,
с обрабатывающим его слотом. При этом обработка выполняется не сразу
путем вызова функции, а с помощью постановки сообщения о сигнале
в очередь для последующей обработки объектом, принимающим этот сигнал.
Такой способ гораздо более гибкий и безопасный, 
что важно при асинхронной обработке событий
в многопоточных программах с параллельным исполнением нескольких
нитей. Специальная утилита moc (Meta-Object Compiler) переводит
программу с расширения языка С++ на чистый С++. Qt, в отличие от
С++ варианта языка CLR-C++ (Сommon Language Runtime),
являющегося частью платформы .Net фирмы Microsoft,
не использует управляемую динамическую память и сборщик мусора.
Благодаря этому Qt-программы быстрее, более надежны и тратят меньше
памяти при выполнении, что позволяет использовать их в системах
реального времени.
</p>

<p>
В Qt в основном разрабатываются оконные графические программы.
Примеры программ, разработанных с помощью Qt:
<ul>
<li>
    Qt-проект "График функции":
    <a href="CppProjects/PlotFunc.zip">PlotFunc.zip</a>.<br/>
    В программе реализовано
    рисование графика произвольной функции от переменной <i>x</i>. 
    Функция задается формулой, которая записывается в текстовом поле окна.
    Проект включает в себя
    парсер формул от одной или двух переменных
    <i>x</i>, <i>y</i>, получающий по
    текстовой записи формулы ее обратную польскую запись,
    которая затем
    используется для вычисления значений функции.<br/>
    <img src="PlotFunc.png"/>
</li>
<li>
    Qt-проект "Интерполяционный полином Ньютона":
    <a href="NewtonPol.zip">NewtonPol.zip</a>.<br/>
    По точкам, отмеченным кликами мыши,
    строится график интерполяционного многочлена. Удобно
    использовать интерполяционный многочлен в форме Ньютона:
    </p>
    <p class="display">
    &nbsp;&nbsp;<i>p</i><sub><i>n</i></sub>(<i>x</i>) =
    <i>a</i><sub>0</sub> +
    <i>a</i><sub>1</sub>(<i>x</i>-<i>x</i><sub>0</sub>) +
    <i>a</i><sub>2</sub>(<i>x</i>-<i>x</i><sub>0</sub>)(<i>x</i>-<i>x</i><sub>1</sub>) +
    <i>a</i><sub>3</sub>(<i>x</i>-<i>x</i><sub>0</sub>)(<i>x</i>-<i>x</i><sub>1</sub>)(<i>x</i>-<i>x</i><sub>2</sub>) +
    . . .<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    + <i>a</i><sub><i>n</i></sub>(<i>x</i>-<i>x</i><sub>0</sub>)(<i>x</i>-<i>x</i><sub>1</sub>)(<i>x</i>-<i>x</i><sub>2</sub>)...(<i>x</i>-<i>x</i><sub><i>n</i>-1</sub>)
    </p>
    <p>
    Многочлен <i>p</i><sub><i>n</i></sub>(<i>x</i>) степени <i>n</i>
    строится по узлам интерполяции
    <i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, ...,
    <i>x</i><sub><i>n</i></sub>,
    в которых он принимает значения
    <i>y</i><sub>0</sub>, <i>y</i><sub>1</sub>, <i>y</i><sub>2</sub>, ...,
    <i>y</i><sub><i>n</i></sub>;
    коэффициенты многочлена вычисляются последовательно по формуле
    <div class="display">
    &nbsp;&nbsp;<i>a</i><sub><i>n</i>+1</sub> =
    (<i>y</i><sub><i>n</i>+1</sub> -
    <i>p</i><sub><i>n</i></sub>(<i>x</i><sub><i>n</i>+1</sub>)) /
    ((<i>x</i><sub><i>n</i>+1</sub> -
    <i>x</i><sub>0</sub>)(<i>x</i><sub><i>n</i>+1</sub> -
    <i>x</i><sub>1</sub>)...(<i>x</i><sub><i>n</i>+1</sub> - 
    <i>x</i><sub><i>n</i></sub>))
    </div>
    <img src="NewtonPol.png"/>
    </p>
</li>
<li>
Qt-проект "Треугольник":
"<a href="CppProjects/Triangle.zip">Triangle.zip</a>".<br/>
По трем точкам, отмеченных кликами мыши, изображается треугольник, его три
биссектрисы и вписанная окружность:<br/>
<img src="QtTriangle.png" /><br/>
Вершины треугольника можно перетаскивать мышью на новую позицию,
при этом картинка изменяется в реальном времени.
</li>
</ul>

<h4>
Задачи на тему Qt
</h4>

<p>
В задаче 1 надо использовать в качестве образца проект "График функции"
<a href="CppProjects/PlotFunc.zip">PlotFunc.zip</a>.
В частности, следует использовать реализованный в нем парсер формул,
который по формуле, зависящей от переменных <i>x</i>, <i>y</i>,
получает ее обратную польскую запись; обратная польская запись формулы
затем используется для вычисления значений
формулы для конкретных численных значений переменных
<i>x</i>, <i>y</i>. Формула может включать числовые константы,
знаки арифметических операций, круглые скобки, стандартные математические
функции (sin, cos, exp, log, atan, sqrt, ...), а также операцию
возведения в степень ^.
</p>

<p>
В задачах 3-6 надо
нарисовать треугольник, задаваемый
кликами мыши, и одну из замечательных точек треугольника,
определяемых как пересечение
чевиан. Нарисовать надо не только саму точку 
(в виде маленького закрашенного кружка), 
но и процесс ее построения.
</p>

<p>
В качестве образца следует использовать Qt-проект
"<a href="CppProjects/Triangle.zip">Triangle.zip</a>".
</p>

<h4>
 Список задач
</h4>

<ol>
<li>
    Задана функция <i>f</i>(<i>x</i>, <i>y</i>).
    (Функция задается в текстовом поле Qt-окна приложения,
    запись функции можно редактировать.)
    Нарисовать ее линию уровня (изогипсу),
    задаваемую уравнением
        <i>f</i>(<i>x</i>, <i>y</i>) = 0.<br/>

    <i>Идея реализации</i>.
    Разбиваем плоскость на маленькие треугольники.
    Для каждого треугольника вычисляем значение функции
    в его вершинах. Если значения одного знака,
    то линия не пересекает треугольник. Иначе
    имеем одну вершину одного знака и две вершины
    другого знака =&gt; используя линейную интерполяцию,
    вычисляем две точки на сторонах треугольника,
    в которых функция принимает значение 0. Получаем отрезок.
    Линии уровня состоят из этих отрезков.
</li>
<!--
<li>
    Пользователь отмечает кликами мыши <i>n</i>+1 точку на плоскости
    (<i>x</i><sub>0</sub>, <i>y</i><sub>0</sub>),
    (<i>x</i><sub>1</sub>, <i>y</i><sub>1</sub>), ...,
    (<i>x</i><sub><i>n</i></sub>, <i>y</i><sub><i>n</i></sub>),
    причем координаты <i>x</i> разных точек отличны друг от друга.
    Нарисовать график интерполяционного полинома степени <i>n</i>,
    постороенного по отмеченным узлам интерполяции:
    <div class="display">
    &nbsp;&nbsp; <i>p</i>(<i>x</i>):   deg(<i>p</i>) = <i>n</i>,
    &nbsp;&nbsp; <i>p</i>(<i>x</i><sub><i>i</i></sub>) = <i>y</i><sub><i>i</i></sub>.
    </div>
    Следует использовать интерполяционную формулу Ньютона.
</li>
-->
<li>
    Нарисовать кривую Безье, построенную по узлам, которые пользователь
    отмечает кликами мыши. Также реализовать возможность перетаскивания
    мышкой отмеченных раньше узлов на новую позицию, при этом уже построенная
    по этим узлам кривая Безье должна изменяться в реальном времени.

    <p>
    <i>Кривая Безье</i> <i>B</i>(<i>t</i>) &mdash; 
    это отображение числового отрезка [0, 1]
    в плоскость <b>R</b><sup>2</sup>:
    <div class="display">
        <i>B</i>: [0, 1] &rarr; <b>R</b><sup>2</sup>
    </div>
    Кривая Безье порядка <i>n</i>
    задается <i>n</i>+1 узлом
    <div class="display">
        <i>p</i><sub>0</sub>, <i>p</i><sub>1</sub>, ..., 
        <i>p</i><sub><i>n</i></sub>.
    </div>
    Кривая нулевого порядка (построеная по одному узлу) &mdash;
    это просто точка. Кривая Безье <i>B</i>(<i>t</i>) порядка <i>n</i>, 
    построенная по узлам
    <i>p</i><sub>0</sub>, <i>p</i><sub>1</sub>, ...,
    <i>p</i><sub><i>n</i></sub>,
    определяется
    рекурсивно через две кривые <i>B</i><sub>0</sub>(<i>t</i>)
    и <i>B</i><sub>1</sub>(<i>t</i>) порядка <i>n</i>-1;
    кривая <i>B</i><sub>0</sub>(<i>t</i>) строится по узлам
    <div class="display">
        <i>p</i><sub>0</sub>, <i>p</i><sub>1</sub>, ...,
        <i>p</i><sub><i>n</i>-1</sub>,
    </div>
    кривая <i>B</i><sub>1</sub>(<i>t</i>) &mdash; по узлам
    <div class="display">
        <i>p</i><sub>1</sub>, <i>p</i><sub>1</sub>, ...,
        <i>p</i><sub><i>n</i></sub>,
    </div>
    Кривая Безье порядка <i>n</i> задается рекурсивно формулой:
    <div class="display">
        <i>B</i>(<i>t</i>) = <i>B</i><sub>0</sub>(<i>t</i>)&middot;(1-<i>t</i>) +
                             <i>B</i><sub>1</sub>(<i>t</i>)&middot;<i>t</i>.
    </div>
    </p>

    <p>
    На картинках ниже изображены кривые Безье, построенные по трем и
    четырем узлам:<br/>
    <img src="Bezier2.png"/>
    <img src="Bezier3.png"/>
    </p>
</li>
<li>
    Нарисовать треугольник и <i>точку Жергона</i> &mdash;
    пересечение отрезков, соединяющих
    вершины треугольника с точками касания
    вписанной окружности.<br/>
    <img src="GergonnePoint.png" width="463" height="468" />
</li>
<li>
    Нарисовать треугольник и <i>точку Нагеля</i> &mdash;
    пересечение отрезков, соединяющих
    вершины треугольника с точками касания
    трех внешне вписанных окружностей.<br/>
    <img src="NagelPoint.png" />
</li>
<li>
    Нарисовать треугольник и <i>точку Лемуана</i>
    &mdash; точку, изогонально
    сопряженную центру тяжести треугольника.
    Она определяется как пересечение
    симмедиан. <i>Симмедиана</i> &mdash; это
    отрезок прямой, симметричной медиане
    треугольника относительно бисектриссы,
    проведенной из той же вершины.<br/>
    <img src="LemoinePoint.png" /><br/>
    На рисунке синяя точка &mdash; это пересечение медиан треугольника.
    Медианы изображены синим цветом,
    биссектрисы &mdash; зеленым, симмедианы &mdash; красным.
    Точка Лемуана изображена красным кружком.
</li>
<li>
    Нарисовать треугольник и <i>точку Ферма-Торричелли</i>,
    а также процесс ее построения.
    Точка Ферма-Торричелли определяется как точка, сумма расстояний от
    которой до вершин треугольника минимальна.
    Если треугольник не тупоугольный или его тупой угол меньше 120 градусов,
    то это точка внутри треугольника, из которой каждая сторона
    видна под углом 120 градусов; иначе это вершина
    тупого угла.<br/>
    <img src="TorricelliPoint.png" /><br/>
</li>
</ol>

<hr/>

<a name="Sem2_2022">
<h2>
Весенний семестр 2024 г.
</h2>
</a>

<h3>
<a href="Drafts_Sem2_2022.html">Записи лекций прошлого года</a> 
(весеннй семестр 2022)
</h3>
<dir style="color:gray;">
<h4>
<a href="Drafts_Sem2_2021.html" style="color:gray;">Записи 
лекций позапрошлого года</a>
(весенний семестр 2021)
</h4>
</dir>

<h2>
Тема 1. Язык программирования Python
</h2>

<hr/>

<h4>
        <a href="MagList2023-24_Sem2.html">
        Журнал группы магистратуры 1 курса,
        весенний семестр 2024 г.</a>
</h4>
<dir>
<a href="MagList2021-22_Sem2.html" style="color:gray;">Журнал 
группы магистратуры 1 курса, весенний семестр прошлого 2022 г.</a>
</dir>

<p>
По каждой теме нужно решить одну задачу.
Номер задачи равен номеру студента в журнале по модулю <i>n</i>,
где <i>n</i> &mdash; число задач по данной теме.
Решения задач присылайте мне на электронную почту в виде
файла, присоединенного к письму (*.py для программ
на языке Python3, *.sage для программ на языке sage).
Адрес моей электронной почты:<br/>
<b>vladimir_borisen (собака) mail.ru</b><br/>
В теме письма (поле Subject:) должно быть слово "Магистратура".
</p>

<h2>
Тема 1. Язык программирования Python
</h2>

<h3>
1.0. Python: задачи для разминки
</h3>

Примеры программ на языке Python:
<ul>
<li>
    разложение числа на множители:
    <a href="factor.py">factor.py</a>
</li>
<li>
    печать счастливых билетов длины n:
    <a href="luckyTickets.py">luckyTickets.py</a>
</li>
<li>
    алгоритмы теории чисел:
    <a href="numTheory.py">numTheory.py</a>
</li>
</ul>

<font color="gray">
<h4>Домашнее задание 1 (прошлый год)</h4>

<p>
В задании 3 варианта, надо сделать ту задачу, номер которой
совпадает по модулю 3 с номером студента по журналу.
</p>

<ol>
<li>
    Написать функцию для числа счастливых билетов длины n,
    которая будет работать разумное время 
    по крайней мере для n &le; 12.
</li>
<li>
    Написать функцию, проверяющую, является ли число m полусовершенным.
    Число m совершенное, если оно равно сумме своих собственных
    делителей. Примеры:
    <div class="display">
        6 = 1 + 2 + 3<br/>
        28 = 1 + 2 + 4 + 7 + 14
    </div>
    Число m называется ПОЛУсовершенным, если оно равно сумме
    какого-то ПОДМНОЖЕСТВА своих собственных делителей.

    <p>
    <i>Указание:</i>
    следует<br/>
    1) найти список d всех собственных делителей числа m;<br/>
    2) решить задачу о рюкзаке napsack(d, m).
    </p>

    <p>
    <i>Задача о рюкзаке</i><br/>
    Имеется рюкзак объема m и список вещей, содержащий объемы
    каждой вещи. Можно ли какими-то вещами из этого списка
    (не обязательно всеми) заполнить рюкзак доверху?
<pre>
        d = [1, 2, 5, 3, 7, 11]   m = 10
        Можно ли из этого списка выбрать числа,
                    сумма которых равна 10?
        2, 5, 3
        3, 7
        1, 2, 7
</pre>
    Эта задача NP-полная и для нее не существует хорошего
    решения, кроме как полного перебора всех подмножеств.
    Но, если не искать самого быстрого решения, то она легко
    решается, например, применением рекурсии.
</li>
<li>
    Реализовать функцию nextPermutation(s),
    на вход подается список чисел, на выходе этот список изменяется.
    Функция возвращает True, если перестановка была не последней,
    и False, если следующей перестановки нет.
    Используется следующий алгоритм:
    <div class="display">
    1) находим, идя с конца перестановки к началу, максимальную
       возрастающую последовательность
       в конце перестановки (в примере выделена красным);<br/>
<pre>
        6, 3, 1, 2, 10, 4, <b><font color="blue">9</font>, <font color="red">12, 11, 8, 7, 5</font></b>
</pre>
2) для предшествующего к ней элемента <i>x</i>
   (в примере <i>x</i>=<font color="blue">9</font>, выделен синим)
   находим минимальный элемент <i>y</i> возрастающей последовательности,
   больший <i>x</i> (в примере
       <i>y</i>=<font color="red"><u>11</u></font>, отмечен подчеркиванием);<br/>
<pre>
        6, 3, 1, 2, 10, 4, <b><font color="blue">9</font>, <font color="red">12, <u>11</u>, 8, 7, 5</font></b>
</pre>
    3) меняем местами элементы <i>x</i> и <i>y</i> и затем упорядочиваем
       элементы в конце перестановки, следующие за элементом <i>y</i>
       (для этого используем метод sort для отрезка списка, следующего за <i>y</i>).
<pre>
        6, 3, 1, 2, 10, 4, <b><font color="red"><u>11</u>, 5, 7, 8,</font> <font color="blue">9</font>, <font color="red">12</font></b>
</pre>
    </div>
</li>
</ol>
</font>

<h3>
1.1. Элементы теории чисел
</h3>

<b><a href="NumberTheory.html">Кодирование с открытым ключом 
и элементы теории чисел</a></b>

<p>
<i>Содержание лекции</i>:
<ul>
<li>
    <a href="NumberTheory.html#Zm">
    Кольцо вычетов по модулю <i>m</i>
    </a>
</li>
<li>
    <a href="NumberTheory.html#FermaTheorem">Малая теорема Ферма</a>,
    <a href="NumberTheory.html#ChineseRemainderTheorem">китайская теорема об остатках</a>,
    <a href="NumberTheory.html#EulerTheorem">теорема Эйлера</a>
</li>
<li>
    <a href="NumberTheory.html#NumberTheoryAlgs">Основные алгоритмы теории чисел:</a>
    <a href="NumberTheory.html#EuclidAlg">алгоритм Евклида</a>,
    <a href="NumberTheory.html#ExtendedEuclidAlg">расширенный алгоритм Евклида</a>,
    <a href="NumberTheory.html#FastPower">быстрое возведение в степень</a>,
    <a href="NumberTheory.html#ChineseRemainderAlg">алгоритм в китайской теореме об остатках</a>,
    <a href="NumberTheory.html#SqrtModP">извлечение квадратного корня 
        в поле вычетов по модулю <i>p</i></a>.
<li>
    <a href="NumberTheory.html#FermaTest">Тест простоты Ферма и кармайкловы числа</a>
</li>
<li>
    <a href="NumberTheory.html#PrimeTest">Вероятностный тест простоты Миллера-Рабина</a>
</li>
<li>
    <a href="NumberTheory.html#RSA">Кодирование с открытым ключом, схема RSA</a>
</li>
<li>
    <a href="NumberTheory.html#Factorization">
    Алгоритмы факторизации</a>
    (разложения числа на множители):
    <a href="NumberTheory.html#RhoPollardFactorization">&rho;-алгоритм Полларда<a> 
    и
    <a href="NumberTheory.html#P1PollardFactorization">
    <i>p</i>-1 алгоритм Полларда</a>.
</li>
</ul>
</p>

<p>
<b><a href="NumberTheory.pdf">Презентация: теория чисел в криптографии</a></b>
</p>

<p>
Файл <a href="numberth.py">numberth.py</a>:<br/>
реализация базовых алгоритмов теории чисел на Python
<ul>
<li>
    Вычисление наибольшего общего делителя двух целых чисел
</li>
<li>
    Расширенный алгоритм Евклида &mdash; представление наибольшего
    общего делителя <i>d</i> целых чисел <i>m</i>, <i>n</i> 
    в виде линейной комбинации этих чисел с целыми коэффициентами:
    <p class="display">
        <i>d</i> = <i>u</i>&middot;<i>m</i> + <i>v</i>&middot;<i>n</i>
    </p>
</li>
<li>
    Вычисление обратного элемента в кольце вычетов по модулю <i>m</i>
</li>
<li>
    Алгоритм быстрого воззведения в степень 
    в кольце вычетов по модулю <i>m</i>
</li>
</ul>

<a name="HW_NumberTheory">
<h4>Список задач</h4>
<ol>
<li>
    Реализовать вероятностный тест простоты Миллера-Рабина.
</li>
<li>
    Реализовать алгоритм для Китайской теоремы об остатках.
</li>
<li>
    Факторизовать целое число с помощью &rho;-алгоритма Полларда.
</li>
<li>
    Факторизовать целое число с помощью p-1-алгоритма Полларда.
</li>
<li>
    Вычислить квадратный корень из <i>x</i> в поле
    <b>Z</b><sub><i>p</i></sub> (<i>p</i> &mdash; простое число),
    т.е. найти <i>r</i> такое, что
    <i>r</i><sup>2</sup> &equiv; <i>x</i> (mod <i>p</i>).

</li>
</ol>
</a>

<ul>
<li> 
    Необязательная задача (ее можно выбрать <i>вместо</i>
    любой из перечисленных выше задач):
    <font color="blue">
    факторизовать целое число с помощью алгоритма Ленстра на
    эллиптических кривых.
    </font>
</li>
</ul>

<h3>
1.2. Классы в языке Python
</h3>

<p>
<b>Презентация:</b>
<a href="../AlgebraPract/PythonClasses.pdf">Классы в Python'е</a>
на примере классов R2Vector и R2Point для поддержки графики
на плоскости <b><i>R</i></b><sup>2</sup>.<br/>
Оба класса содержатся в модуле R2Graph, 
файл "<a href="R2Graph.py">R2Graph.py</a>".
</p>

<p>
Еще один несложный пример класса:
класс Zm, реализующий элементы кольца вычетов
по модулю <i>m</i>, файл "<a href="Zm.py">Zm.py</a>".
</p>

<a name="HW_PythonClasses">
<h4>Список задач</h4>
<ol>
<li>
    Реализовать класс Polynomial, представляющий многочлен
    произвольной степени с коэффициентами в поле рациональных
    чисел. Должны быть реализованы операции сложения, умножения,
    деления с остатком, вычисление наибольшего общего делителя
    многочленов, производной многочлена, а также вычисление
    многочлена с теми же корнями, свободного от кратных корней, 
    т.е. частного от
    деления многочлена <i>f</i> на gcd(<i>f</i>, <i>f'</i>).

    <p>
    <i>Указание:</i> в Python'е рациональные числа представлены
    классом Fraction в модуле fractions.
    </p>
    <pre>
    &gt;&gt;&gt; from fractions import *
    &gt;&gt;&gt; x = Fraction(3, 7)
    &gt;&gt;&gt; y = Fraction(1, 5)
    &gt;&gt;&gt; x + y
    Fraction(22, 35)
    </pre>
</li>

<li>
    Та же задача, но для многочленов над полем <b>Z</b><sub><i>p</i></sub>.<br/>
    (<i>Следует в решении использовать
    класс Zm, реализующий элементы кольца вычетов
    по модулю <i>m</i>, файл "<a href="Zm.py">Zm.py</a>".</i>)
</li>

<li>
    Реализовать класс "Элементы поля <b>GF</b><sub><i>p</i><sup>2</sup></sub>",
    где <i>p</i> &mdash; простое число.<br/>
    См. <a href="../AlgebraPract/GFp2.html">Конструкция конечного поля из
    <i>p</i><sup>2</sup> элементов</a>.<br/>
    (<i>Следует в решении использовать
    класс Zm, реализующий элементы кольца вычетов
    по модулю <i>m</i>, файл "<a href="Zm.py">Zm.py</a>".</i>)
</li>

<li>
    Реализовать класс "Матрицы порядка <i>m</i>&times;<i>n</i>
    над полем рациональных чисел". Должны быть реализованы операции
    над матрицами, приведение матрицы к ступенчатому виду, вычисление ранга,
    а также для квадратной матрицы вычисление определителя и обратной матрицы и
    решение линейной системы с невырожденной матрицей.
</li>

<li>
    Та же задача, но для матриц над полем <b>Z</b><sub><i>p</i></sub>.<br/>
    (<i>Следует в решении использовать
    класс Zm, реализующий элементы кольца вычетов
    по модулю <i>m</i>, файл "<a href="Zm.py">Zm.py</a>".</i>)
</li>
</ol>
</a>

<h3>
1.3. Работа с матрицами в Python'е. Модуль numpy
</h3>

<font color="gray">

<h4>Из программы прошлых лет</h4>

<p>
Матрица в Питоне обычно представляется списком строк, где каждая строка
&mdash; это список чисел. Например,
<pre>
    &gt;&gt;&gt; a = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
    &gt;&gt;&gt; print(a)
    [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
</pre>
</p>

<p>
Замечательная особенность Питона состоит в том, что в нем реализованы
целые числа неограниченного размера. Это позволяет реализовать также и
рациональные числа. Реализация рациональных чисел с помощью целых чисел
типа int или long long в языке C++ бессмысленна, т.к. при арифметических
действиях с рациональными числами их знаменатели растут очень быстро
и почти сразу наступает переполнение. В Питоне переполнений не бывает.
Рациональные числа представлены в Питоне классом Fraction в модуле
fractions:
<pre>
    &gt;&gt;&gt; from fractions import *
    &gt;&gt;&gt; a = Fraction(1, 3)
    &gt;&gt;&gt; print(a)
    1/3
    &gt;&gt;&gt; b = Fraction(1, 4)
    &gt;&gt;&gt; print(b)
    1/4
    &gt;&gt;&gt; print(a + b)
    7/12
</pre>
</p>

<p>
Рациональные числа типа Fraction позволяют использовать точную арифметику
и получать точный результат, в отличие от вещественных чисел типа float.
Например, для типа float бессмыслено сравнивать числа на точное равенство,
результат непредсказуем:
<pre>
    &gt;&gt;&gt; a = 1/3
    &gt;&gt;&gt; a
    0.3333333333333333
    &gt;&gt;&gt; b = 1/4
    &gt;&gt;&gt; b
    0.25
    &gt;&gt;&gt; a + b
    0.5833333333333333
    &gt;&gt;&gt; 7/12
    0.5833333333333334
    &gt;&gt;&gt; 1/3 + 1/4 == 7/12
    False
</pre>
Неожиданный результат! Для вещественных чисел, представленных типом
float, сумма 1/3 + 1/4 не равна 7/12 (отличие мизерное, 
но точного равенства нет).
</p>

<p>
Для матриц над полем рациональных чисел в Питоне можно реализовать
метод Гаусса приведения матрицы к ступенчатому в точности так, как
этот метод рассматривается в курсе математики. Это позволяет с помощью
программ на Питоне решать задачи, которые обычно даются первокурсникам
на практических занятиях в курсе алгебры или линейной алгебры:
приведение матрицы к ступенчатому виду, вычисление определителя матрицы,
решение систем линейных уравнений, вычисление обратной матрицы и т.п.
</p>

<p>
Отметим, что для матриц из вещественных чисел метод Гаусса
имеет свои особенности: во-первых, мы не можем просто считать элемент
равным нулю, поскольку точных равенств при работе с элементами типа float
не бывает! Поэтому мы считаем элемент матрицы нулевым, если его абсолютная
выличина не превосходит маленького числа eps, например,
eps = 1e-8:
<pre>
    &gt;&gt;&gt; (1/3 + 1/4) - 7/12 == 0
    False
    &gt;&gt;&gt; eps = 1e-8
    &gt;&gt;&gt; abs((1/3 + 1/4) - 7/12) &lt;= eps
    True
</pre>
Во-вторых, в методе Гаусса при приведении матрицы к ступенчатому
виду нельзя выбирать произвольный ненулевой разрешающий элемент в столбце.
Если мы выберем маленький ненулевой элемент, то при делении на него
строка в результате будет умножаться на очень большое число,
что приводит к экспоненциальному росту ошибок округления
и неустойчивости алгоритма.
В результате вместо правильного (или близкого к правильному)
ответа мы будем получать просто мусор! Надо обязательно выбирать элемент,
максимальный по абсолютной величине в столбце, чтобы при делении на него
строка умножалась на коэффициент, не превосходящий единицы.
</p>

<p>
В файле <a href="Python/matrix.py">matrix.py</a> реализована работа
с матрицами на полем рациональных чисел (тип Fraction)
и над полем вещественных чисел (тип float). Функция
echelonFormOfRationalMatrix(<i>a</i>) приводит матрицу рациональных чисел
к ступенчатому виду и возвращает пару
(ступенчатый вид матрицы, ранг матрицы), при этом сама матрица <i>a</i>
не изменяется (действия производятся с копией матрицы).
Функция showRationalMatrix(<i>a</i>) преобразует объект "матрица"
к текстовому виду так, чтобы потом матрицу можно было красиво напечатать:
<pre>
    &gt;&gt;&gt; from matrix import *
    &gt;&gt;&gt; a = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
    &gt;&gt;&gt; print(showRationalMatrix(a))
    [1 2 3]
    [4 5 6]
    [7 8 0]
    &gt;&gt;&gt; (b, rank) = echelonFormOfRationalMatrix(a)
    &gt;&gt;&gt; print(showRationalMatrix(b))
    [ 1  2  3]
    [ 0 -3 -6]
    [ 0  0 -9]
</pre>
</p>

<p>
Аналогичные функции echelonFormOfRealMatrix(a) и
showRealMatrix(a) реализованы для вещественных матриц:
<pre>
    &gt;&gt;&gt; a = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
    &gt;&gt;&gt; (b, rank) = echelonFormOfRealMatrix(a)
    &gt;&gt;&gt; print(showRealMatrix(b))
    [     -7.0000      -8.0000      -0.0000]
    [     -0.0000      -0.8571      -3.0000]
    [      0.0000       0.0000       4.5000]
</pre>
Кроме того, в модуле <a href="Python/matrix.py">matrix.py</a>
реализованы функции вычисления определителя матрицы,
умножения матриц, а также выполнение элементарных преобразований
и копирование матриц.
</p>
</font>

<h4>
Модуль numpy
</h4>

<p>
В реальных приложениях, однако, никто не работает с матрицами
большого размера как с базовыми списками Питона (матрица как список
строк, каждая строка &mdash; список чисел). Связано это с тем,
что такая работа с матрицами не очень эффективна.
Для представления массивов и матриц (а также многомерных массивов) 
обычно используют модуль numpy и класс numpy.ndarray. Пример:
<pre>
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array([[1., 2., 3.], [4., 5., 6.], [7., 8., 0.]])
&gt;&gt;&gt; a
array([[1., 2., 3.],
       [4., 5., 6.],
       [7., 8., 0.]])
&gt;&gt;&gt; type(a)
&lt;class 'numpy.ndarray'&gt;
&gt;&gt;&gt; a.shape
(3, 3)
&gt;&gt;&gt; a[0, 0]
1.0
&gt;&gt;&gt; a[1][0]
4.0
&gt;&gt;&gt; a[1]
array([4., 5., 6.])
&gt;&gt;&gt; a[:,[1]]
array([[2.],
       [5.],
       [8.]])
</pre>
</p>

<a name="HW_NumpyMatrices">
<h4>Задачи на работу с матрицами в Python'е</h4>

<p>
В задании 2 варианта, нужно сделать одну задачу.
Студенты с нечетными номерами по журналу делают задачу 1,
с четными &mdash; задачу 2.
Во всех задачах надо реализовать функцию, которая в зависимости
от варианта возвращает либо матрицу, либо линейный массив.
<!--
Реализованную функцию надо добавить в файл
<a href="Python/npmatrix.py">npmatrix.py</a>.
-->
</p>

<p>
В задачах предполагается, что матрицы и линейные массивы
представляются numpy-массивами типа numpy.ndarray.
Во всех вариантах используйте уже готовую функцию
<div class="display">
    (rank, det) = gauss(a)
</div>
которая приводит матрицу <i>a</i> к ступенчатому виду и
возвращает ранг и определитель матрицы (для неквадратной матрицы
определитель не вычисляется и возвращается 0). Матрица <i>a</i>
представлена в виде двумерного numpy-массива с вещественными
значениями. Функция реализована в файле
"<a href="gauss.py">gauss.py</a>".
</p>

<p>
Отметим еще раз, что функция <i>не должна ничего печатать</i>
(и уж тем более не должна ничего вводить с клавиатуры!).
Результатом работы функции должно быть вычисление требуемого
объекта, который функция должна возвращать с помощью оператора
return. Исходные аргументы функции при этом меняться не должны.
</p>

<ol>
<li>
Вычислить обратную матрицу к невырожденной квадратной 
вещественной матрице:
<pre>
    b = inverseMatrix(a)
</pre>
</li>
<li>
Решить систему линейных уравнений с
невырожденной квадратной вещественной матрицей:
<pre>
    x = solveLinearSystem(a, b)
</pre>
Здесь <i>a</i> &mdash; матрица вещественных чисел,
<i>b</i> &mdash; массив свободных членов уравнений.
Функция должна вернуть массив <i>x</i> вещественных чисел,
представляющий решение системы <i>a</i>*<i>x</i> = <i>b</i>.
</li>
</ol>
</a>

<p>
Отметим, что обе эти задачи реализованы в подмодуле linalg модуля numpy
(linalg от слов линейные алгоритмы).
Вычисление обратной матрицы к матрице <i>a</i>:
<pre>
    ainv = numpy.linalg.inv(a)
</pre>
Решение системы линейных уравнений <i>a</i>&middot;<i>x</i> = <i>b</i>:
<pre>
    x = numpy.linalg.solve(a, b)
</pre>
Примеры:
<pre>
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6],[7,8,0]], dtype="float64")
&gt;&gt;&gt; ainv = np.linalg.inv(a)
&gt;&gt;&gt; ainv
array([[-1.77777778,  0.88888889, -0.11111111],
       [ 1.55555556, -0.77777778,  0.22222222],
       [-0.11111111,  0.22222222, -0.11111111]])
&gt;&gt;&gt; ainv @ a
array([[ 1.00000000e+00, -4.44089210e-16,  0.00000000e+00],
       [ 2.22044605e-16,  1.00000000e+00,  0.00000000e+00],
       [ 1.11022302e-16,  1.11022302e-16,  1.00000000e+00]])
&gt;&gt;&gt; b = np.array([2., 3., 5.])
&gt;&gt;&gt; x = np.linalg.solve(a, b)
&gt;&gt;&gt; x
array([-1.44444444,  1.88888889, -0.11111111])
&gt;&gt;&gt; a @ x
array([2., 3., 5.])
</pre>
Однако пользоваться функциями из модуля numpy.linalg запрешено,
требуется самостоятельно реализовать функции вычисления обратной матрицы
и решения системы линейных уравнений.
</p>


<h3>1.4. Графика и оконное программирование на языке Python</h3>

<p>
Для графики мы используем модуль tkinter, представляющий собой
наиболее простой оконный интерфейс. Мы также используем небольшой
модуль <a href="R2Graph.py">R2Graph.py</a>,
в котором реализованы классы R2Vector и R2Point, с помощью которых
удобно решать разные геометрические задачи на плоскости.
</p>

Подробный текст лекции:
<a href="PythonGraphics.html">Графика на языке Python</a>

<h3>
Примеры графических программ, использующих модуль tkinter
</h3>

<ul>
<li>
    Рисование графика функции, заданной в тексте программы,
    а также точек, отмеченных кликами мыши:
    <a href="plotFunc.py">plotFunc.py</a><br/>
    <img src="plotFunc.png"/>
</li>
<li>
    Нариcовать треугольник по кликам мыши, а также
    три его биссектрисы и вписанную окружность:
    <a href="triangle3.py">triangle3.py</a><br/>
    <img src="triangle3.png"/>
</li>
<li>
    Та же программа "Треугольник", но с возможностью
    перетаскивания его вершин мышью, при этом картинка
    меняется в реальном времени:
    <a href="triangle4.py">triangle4.py</a><br/>
</li>
<li>
    Цифровые часы: <a href="dclock.py">dclock.py</a><br/>
    <img src="dclock.png"/>
</li>
<li>
    Аналоговые часы: <a href="analogclock.py">analogclock.py</a><br/>
    <img src="analogclock.png"/>
</li>
</ul>

<!--

<h4>
Задачи по геометрии
</h4>

<ol>
<li>
Нарисовать треугольник и точку Ферма-Торичелли (точка, минимизирующая
сумму расстояний до вершин треугольника), изобразив процесс ее построения.
</li>

<li>
Нарисовать треугольник, три внешне вписанных окружности и точку Нагеля.
</li>

<li>
Нарисовать треугольник и точку Лемуана, которая построена как
точка, изогонально сопряженная к точке пересечения медиан.
</li>

<li>
Нарисовать график интерполяционного многочлена, построенного по
узлам, отмеченным кликами мыши. Для вычисления интерполяционного многочлена
использовать формулу Ньютона.
</li>

<li>
Нарисовать кривую Безье порядка <i>n</i> по заданному массиву
точек размера <i>n</i>+1.
</li>

</ol>

-->

<h3>
1.5. Элементы машинного обучения.
Задача регрессии. Метод опорных векторов
</h3>

<h4>
1.5.1.
Задача регрессии и ее решение методом наименьших квадратов
</h4>

<p><font size="+1">
<a href="../MasterAI/LeastSquares.html">Описание метода 
наименьших квадратов</a>.
</font></p>

<a name="HW_LeastSquares">
<h4>
Домашнее задание
</h4>

<p>
Написать, используя модуль tkinter, оконное графическое приложение,
иллюстрирующее метод наименьших квадратов.
Пользователь отмечает мышью набор точек на плоскости,
программа должна найти многочлен заданной степени,
минимизирующий сумму квадратов уклонений значений многочлена
от значений, заданных узлами интерполяции:<br/>
<img src="regressionPython.png"/><br/>
В качестве образца следует использовать
программу, рисующую график интерполяционного многочлена
по заданным узлам интерполяции; многочлен вычисляется по формуле
Ньютона:<br/>
<img src="NewtonPolTkinter.png"/><br/>
Приложение использует два файла:
"<a href="newton.py">newton.py</a>" (оконный интерфейс),
"<a href="newtonPol.py">newtonPol.py</a>" (вычисление полинома Ньютона).
Архив всех файлов:
"<a href="newtonInterpol.zip">newtonInterpol.zip</a>".
</p>
</a>

<hr/>

<h4>
1.5.2.
Борьба с выбросами в задаче регрессии. Использование
функции потерь Хубера
</h4>

<p><font size="+1">
<a href="../MasterAI/index.html#Sem7_2sem">Использование
функции потерь Хубера в задаче линейной регрессии</a>.
</font></p>

<h4>
1.5.3.
Борьба с выбросами в задаче регрессии. Минимизация
функции ошибки MAE (средняя абсолютная величина отклонения)
методами линейного программирования
</h4>

<p><font size="+1">
<a href="../MasterAI/index.html#Sem8_2sem">Использование
методов линейного программирования в задаче регрессии</a>.
</font></p>

<a name="HW_HuberMAE">
<h4>Домашнее задание</h4>

<!--
<ol>
<li>
Реализовать оконную программу, по данному набору узлов
и заданной степени многочлена вычисляющую многочлен методом
наименьших квадратов (минимизирующий функцию ошибки MSE),
и нарисовать его график.
</li>

<li>
Реализовать оконную программу, по данному набору узлов
и заданной степени многочлена вычисляющую многочлен путем
минимизации функции потерь Хубера (приблизительно
минимизируя функцию ошибки MAE), и нарисовать его график.
</li>

<li>
Реализовать оконную программу, по данному набору узлов
и заданной степени многочлена вычисляющую многочлен методом
линейного программирования, который минимизирует функцию ошибки MAE,
и нарисовать его график.
</li>
</ol>
-->

<p>
Дополнить программу
"<a href="huberRegression.py">huberRegression.py</a>",
которая вычисляет линейную регрессию, используя либо
метод наименьших квадратов (т.е. минимизируя 
квадратичную функцию ошибки MSE), либо минимизируя функцию
ошибки, определенную с помощью функции Хубера.
Архив всех файлов программы:
"<a href="huberRegression.zip">huberRegression.zip</a>".
В программе надо дополнительно реализовать третий способ
вычисления параметров регрессии, который минимизирует
среднюю величину абсолютной ошибки MAE, используя методы
линейного программирования. Модифицированная программа
должна выглядеть примерно так:<br/>
<img src="MSE_Huber_MAERegression.png"/><br/>
На приведенном скриншоте по заданным узлам
строится прямая, т.е. полином степени 1.
Синим цветом нарисована прямая, построенная методом наименьших
квадратов, красным &mdash; с использованием функции Хубера,
зеленым &mdash; с помощью минимизации функции MAE 
методом линейного программирования.
Можно также построить полином большей степени, например, третьей
(степень полинома задается с помощью слайдера):<br/>
<img src="MSE_Huber_MAERegression3.png"/><br/>
Здесь синяя кривая построена методом наименьших
квадратов, зеленая &mdash;
методом линейного программирования. Видно, что во втором случае
влияние выбросов на форму кривой значительно меньше.
Красная кривая, построенная с использованием функции Хубера, здесь не
показана, потому что она в данном случае почти совпадает
с зеленой кривой и на картинке две кривые почти полностью
накладываются друг на друга.
</p>
</a>

<hr/>


<h3>
1.5.4. Метод опорных векторов, классический линейный вариант
</h3>

<dir>
<i>Содержание</i>:
постановка задачи нахождения линейного классификатора
для разделения двух классов объектов, которые описываются
векторами <i>n</i>-мерного проостранства. Метод опорных векторов,
который вычисляет гиперплоскость коразмерности 1, разделяющую
два класса точек; различные функции потери.
Графическая программа на Python+tkinter, иллюстрирующая
метод опорных векторов:
"<a href="../MasterAI/svm.py">svm.py</a>" (программа использует также модуль
<a href="../MasterAI/R2Graph.py">R2Graph.py</a>, архив всех файлов:
"<a href="../MasterAI/svm.zip">svm.zip</a>").<br/>
<img src="../MasterAI/SVM0.png"/><br/>
</dir>

<h4>
<a href="../MasterAI/SVM.html">Описание метода опорных векторов
(Support Vector Machine)</a>
</h4>

<hr/>

<h3>
1.5.5. Нелинейный метод опорных векторов
</h3>

<dir>
<i>Содержание</i>:
    Идея нелинейного метода опорных векторов:
    добавление некоторого набора базовых функций от исходных
    признаков объекта и расширение описания объекта
    с их помощью. Построение линейного классификатора
    в пространстве более высокой размерности.
</dir>

<p>
В классическом методе опорных векторов мы имеем два класса
объектов, каждый объект описывается <i>n</i> признаками, представляемыми
вещественными числами. Таким образом, объекты 
<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, &hellip; <i>x</i><sub><i>k</i></sub>
представляются точками <i>n</i>-мерного пространства; координаты такой точки
равны значениям признаков объекта. В тренировочной выборке
объекты <i>x</i><sub><i>i</i></sub> первого класса отмечены значением
<i>y</i><sub><i>i</i></sub> = 1, объекты <i>x</i><sub><i>j</i></sub>
второго класса &mdash;
значением <i>y</i><sub><i>j</i></sub> = -1. В методе опорных векторов SVM
(Support Vector Machine) строится линейный классификатор <i>f</i>(<i>x</i>),
который определяется как гиперплоскость, разделяющая два класса точек:
<div class="display">
    <i>f</i>(<i>x</i>) = &langle;<i>w</i>, <i>x</i>&rangle; &minus; <i>b</i>,<br/>
    <i>x</i>, <i>w</i> &isin; <b>R</b><sup><i>n</i></sup>,
    <i>b</i> &isin; <b>R</b>.
</div>
(угловые скобки здесь обозначают скалярное произведение векторов).
Если <i>f</i>(<i>x</i>) &ge; 0, то классификатор относит точку <i>x</i>
к первому классу, если <i>f</i>(<i>x</i>) &lt; 0, то ко второму.
Разделяющая гиперплоскость задается уравнением
<div class="display">
    &langle;<i>w</i>, x&rangle; &minus; <i>b</i> = 0.
</div>
Здесь <i>w</i> &mdash; вектор нормали к гиперплоскости, число
<i>b</i> задает смещение гиперплоскости относительно начала координат.
Таким образом, линейный классификатор
<i>f</i>(<i>x</i>) = <i>f</i><sub><i>w</i>,<i>b</i></sub>(<i>x</i>)
задается параметрами <i>w</i>, <i>b</i>.
</p>

<p>
В классическом методе опорных векторов далеко не всегда можно разделить
гиперплоскостью два класса точек в <i>n</i>-мерном пространстве:<br/>
<img src="../MasterAI/SVMNonlinear.png" /><br/>
Идея нелинейного метода опорных векторов состоит в том, чтобы дополнить
исходный набор из <i>n</i> признаков объекта дополнительными признаками, 
которые вычисляются как некоторые функции от набора исходных признаков.
В результате мы получим
множество точек в пространстве более высокой размерности, где каждая точка
представляет расширенный набор признаков исходного объекта. Можно надеяться,
что в пространстве более высокой размерности эти точки уже можно
разделить гиперплоскостью.
</p>

<p>
Итак, пусть отображение
<div class="display">
    &phi;: <b>R</b><sup><i>n</i></sup> &rarr; <b>R</b><sup><i>m</i></sup>,
    &nbsp; <i>m</i> &gt; <i>n</i>,<br/>
    &phi;(<i>x</i>) =
        (&phi;<sub>1</sub>(<i>x</i>),
         &phi;<sub>2</sub>(<i>x</i>),
         &hellip;
         &phi;<sub><i>m</i></sub>(<i>x</i>)), &nbsp;&nbsp;
    где
    <i>x</i> = (<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, &hellip;
                <i>x</i><sub><i>n</i></sub>),
</div>
переводит исходный набор признаков
<i>x</i> = (<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, &hellip;
<i>x</i><sub><i>n</i></sub>)
в расширенный набор
(&phi;<sub>1</sub>(<i>x</i></sub>),
&phi;<sub>2</sub>(<i>x</i></sub>),
&hellip;
&phi;<sub><i>m</i></sub>(<i>x</i></sub>)).
Пусть нам удалось построить хороший линейный классификатор <i>F</i>(<i>t</i>)
в пространстве расширенных признаков, 
где <i>t</i>&isin;<b>R</b><sup><i>m</i></sup>:
<div class="display">
    <i>F</i>(<i>t</i>) =
    &langle;<i>W</i>, t&rangle; &minus; <i>B</i>,
    &nbsp;&nbsp;
    где <i>W</i>, <i>t</i>&isin;<b>R</b><sup><i>m</i></sup>,
    <i>B</i>&isin;<b>R</b>.
</div>
Тогда классификатор в исходном пространстве (уже нелинейный!) задается
формулой
<div class="display">
    <i>f</i>(<i>x</i>) = <i>F</i>(&phi;(<i>x</i>)) =
    &langle;<i>W</i>, &phi;(<i>x</i>)&rangle; &minus; <i>B</i>.
</div>
</p>

<p>
В простейшем случае в качестве функций
&phi;<sub>1</sub>(<i>x</i><sub>1</sub>, &hellip; <i>x</i><sub><i>n</i></sub>),
&phi;<sub>2</sub>(<i>x</i><sub>1</sub>, &hellip; <i>x</i><sub><i>n</i></sub>),
&hellip;,
&phi;<sub><i>m</i></sub>(<i>x</i><sub>1</sub>, &hellip; <i>x</i><sub><i>n</i></sub>)
можно взять всевозможные мономы степени не выше <i>d</i> от
переменных
<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, &hellip; <i>x</i><sub><i>n</i></sub>
(то есть от исходных признаков).
</p>

<p>
Пусть, например, <i>d</i> = 2. Пусть число исходных признаков <i>n</i> = 2,
т.е. объекты представляются точками плоскости <b>R</b><sup>2</sup>.
Тогда расширенный набор признаков представляется всеми мономами
степени не выше 2 от переменных <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>:
<div class="display">
    &phi;(<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>) =
    (1, <i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>,
    <i>x</i><sub>1</sub><sup>2</sup>, 
    <i>x</i><sub>1</sub><i>x</i><sub>2</sub>,
    <i>x</i><sub>2</sub><sup>2</sup>),
</div>
и размерность пространства расширенных признаков равна 6.
</p>

<p>
Программа
"svmNonlinear.py"
иллюстрирует использование нелинейного метода опорных векторов.
Исходные объекты представляются точками плоскости двух цветов,
отмечаемые кликами левой и правой клавиш мыши.
В качестве расширенных признаков используются все мономы степени не выше
<i>d</i> от координат
<i>x</i> и <i>y</i> очередной точки;
степень <i>d</i> задается с помощью слайдера в пределах от 1 до 5. Программа
после построения нелинейного классификатора <i>f</i>(<i>x</i>) изображает
линию нулевого уровня функции
<div class="display">
    <i>f</i>(<i>x</i>) = 0,
</div>
эта линия разделяет два класса точек. Ниже приведены скриншоты этой
программы для различных значений максимальной степени мономов, 
которые используются как расширенные наборы признаков.
<p>

<h4>Классический случай: степень 1</h4>
<img src="../MasterAI/SVMNonlinear1.png" /><br/>

<h4>Квадратичные мономы: степень 2</h4>
<img src="../MasterAI/SVMNonlinear2.png" /><br/>

<h4>Кубический многочлен: степень 3</h4>
<img src="../MasterAI/SVMNonlinear3.png" /><br/>

<h4>Многочлен степени 4</h4>
<img src="../MasterAI/SVMNonlinear4.png" /><br/>

<h4>Многочлен степени 5</h4>
<img src="../MasterAI/SVMNonlinear5.png" /><br/>

<p>
В случае полинома высокой степени 5 мы, скорее всего, наблюдаем
переобучение. Также форма разделяющей кривой сильно заисит от гиперпараметра
<i>С</i> и от функции потери.
</p>

<h4>Программа на Питоне (подготовленная в Jupyter-Lab),
иллюстрирующая нелинейный метод опорных векторов</h4>

<pre>
# Non-linear Support Vector Machine method

from scipy.optimize import minimize
import numpy as np
import itertools
import random
from math import sin, cos
import matplotlib.pyplot as plt
from skimage import measure

get_ipython().run_line_magic('matplotlib', 'inline')
plt.axes(aspect="equal")

def monomials(x, degree=1):
    m = [1.]
    for d in range(1, degree+1):
        for c in itertools.combinations_with_replacement(x, d):
            m.append(np.prod(c))
    return np.array(m)


m1 = 100
class1 = [ np.array([
    random.normalvariate(1., 1.5), random.normalvariate(1., 0.5)
]) for i in range(m1) ]

m2 = m1
angle1 = -np.pi*2/3
angle2 = np.pi*2/3
ex = np.array([1., 0.]); ey = np.array([0., 1.])
class2 = []
for i in range(m2):
    phi = random.normalvariate(0., 1.)
    r = random.normalvariate(5., 0.5)
    p = ex*cos(phi)*r + ey*sin(phi)*r
    class2.append(p.copy())
    
x = class1 + class2
x = np.array(x)
y = [1.]*len(class1) + [-1.]*len(class2)
y = np.array(y)
m = len(x)
perm = np.random.permutation(m)
x = x[perm]
y = y[perm]

plt.scatter(
    [c[0] for c in x], [c[1] for c in x],
    color=[ "r" if yy &gt; 0. else "g" for yy in y ]
)

degree = 3
xext = np.array([monomials(xx, degree) for xx in x])
n = len(xext[0])
print("n =", n)
C = 10.    # Hyperparameter
w = np.array([0.]*n)
b = 0.

def hingeLoss(c):
    return max(1. - c, 0.)

def errorFunction(wb):
    w = wb[:-1]
    b = wb[-1]
    w2 = w @ w
    s = 0.
    m = len(xext)
    for i in range(m):
        c = y[i]*(w @ xext[i] - b)
        s += hingeLoss(c)
    return w2 + (C/m)*s

def classifier(p):
    pext = monomials(p, degree)
    return w @ pext - b

res = minimize(errorFunction, np.zeros(n + 1))
w = res.x[:-1]
b = res.x[-1]
print("w =", w)
print(" b =", b)

# Draw the separating line
xmin = min([xx[0] for xx in x]) - 1.
xmax = max([xx[0] for xx in x]) + 1.
ymin = min([xx[1] for xx in x]) - 1.
ymax = max([xx[1] for xx in x]) + 1.
rows = 100
cols = rows

def xcoord(j):
    dx = (xmax - xmin)/cols
    return xmin + j*dx
def ycoord(i):
    dy = (ymax - ymin)/rows
    return ymin + i*dy

# a is a matrix of dimension (rows, cols)
a = np.array([[0.]*steps for iy in range(rows)])
for i in range(rows):
    for j in range(cols):
        xx = np.array([xcoord(j), ycoord(i)])
        a[i, j] = classifier(xx)
nullContours = measure.find_contours(a, 0.)
for c in nullContours:
    plt.plot(
        [xcoord(cc[1]) for cc in c], 
        [ycoord(cc[0]) for cc in c],
        color="blue"
    )
</pre>

<p>
Вот результат работы этой программы (запущенной в среде Jupyter-Lab):<br/>
<img src="svm_nonlinear_out.png"><br/>
Исходный код программы:
"<a href="svmNonlinear.ipynb">svmNonlinear.ipynb</a>".
</p>

<p>
Эта же программа иллюстрирует изображение линий уровня (изолиний,
изогипс) функции от двух переменных
<div class="display">
    <i>f</i>(<i>x</i>, <i>y</i>) = <i>l</i> = const
</div>
В примере мы используем функцию
<div class="display">
    <i>f</i>(<i>x</i>, <i>y</i>) = 
    ((<i>x</i> &minus; 2) + (<i>y</i> &minus; 1))<sup>2</sup>/4 +
    ((<i>x</i> &minus; 2) &minus; (<i>y</i> &minus; 1))<sup>2</sup>
</div>
Вот код программы (в среде Jupyter-Lab):
<pre>
# Drawing Isolines
import numpy as np
import matplotlib.pyplot as plt
from skimage import measure

get_ipython().run_line_magic('matplotlib', 'inline')
plt.axes(aspect="equal")

def f(x, y):
    return ((x - 2) + (y - 1))**2/4 + ((x - 2) - (y - 1))**2

xmin = -5.; xmax = 10.
ymin = -5.; ymax = 10.
m = 100; n = 100

def xcoordinate(j):
    dx = (xmax - xmin)/n
    x = xmin + j*dx
    return x

def ycoordinate(i):
    dy = (ymax - ymin)/m
    y = ymin + i*dy
    return y

a = np.array([[0.]*n for i in range(m)])
for i in range(m):
    y = ycoordinate(i)
    for j in range(n):
        x = xcoordinate(j)
        a[i, j] = f(x, y)
        
for l in range(20):
    level = 0.1*(2**l)
    contours = measure.find_contours(a, level)
    for c in contours:
        plt.plot(
            [ xcoordinate(cc[1]) for cc in c ],
            [ ycoordinate(cc[0]) for cc in c ]
            #, color="blue"
        )
</pre>
</p>

<p>
Вот результат работы этой программы (запущенной в среде Jupyter-Lab):<br/>
<img src="svm_nonlinear_out1.png"><br/>
</p>

<hr/>

<h3>
Ядровые методы и их использование в нелинейном методе
опорных векторов
</h3>
<dir>
<i>Содержание</i>:
ядровой метод опорных векторов использует следующую идею.
Классический метод опорных векторов сводится
к задаче минимизации функции при заданных ограничениях типа
неравенств, которая решается применением теоремы Куна&ndash;Таккера.
При этом минимизируемая функция потерь выражается
через попарные скалярные произведения векторов-признаков объектов
из тренировочной выборки. Таким образом строится линейный классификатор.

<p>
Когда мы заменяем обычное скалярное произведение некоторым ядром,
представляющим собой скалярное произведение векторов, составленных
из набора базисных функций от исходных признаков, то в результате
решения задачи минимизации функции потерь мы получаем
нелинейный классификатор. При этом, несмотря на увеличение размерности
пространства признаков, сложность вычислений остается такой же,
как и в случае исходной линейной задачи.
</p>
</dir>

<h4>
<a href="../MasterAI/KernelSVM.html">Описание
ядрового варианта метода опорных векторов</a>
</h4>

<p>
Вот несколько скриншотов оконной программы на Python+tkinter,
иллюстрирующей применение ядрового метода опорных векторов:<br/>
<i>Гауссовское ядро</i> (RBF)<br/>
<img src="../MasterAI/SVMGaussKernel.png"><br/>
<i>Полиномиальное ядро, степень</i> 2<br/>
<img src="../MasterAI/SVMKernelPoly2.png"><br/>
<i>Полиномиальное ядро, степень</i> 3<br/>
<img src="../MasterAI/SVMKernelPoly3.png"><br/>
</p>

<p>
В этой программе используется модуль sklearn и его 
подмодуль svm, в котором реализован ядровый метод опорных векторов.
В программе кликами мыши задается массив точек points,
при этом точки, отмеченные кликом левой клавиши мыши,
относятся к первому классу, другой клавишей &mdash;
ко второму, номера клавиш мыши содержится в массиве mouseButtons.
Вот как выглядит код, вызывающий метод опорных векторов.
</p>

<p>
Описания и глобальные переменные:
<pre>
import numpy as np
from sklearn.svm import SVC

classifier = SVC(kernel="rbf")
</pre>
Обучение классификатора на тренировочной выборке:
<pre>
        global classifier
        . . .
        if kernel == "rbf":
            classifier = SVC(C=c, kernel="rbf")
        else:
            classifier = SVC(C=c, kernel="poly", degree=polynomialDegree)

        data = [
            [points[i].x, points[i].y]
            for i in range(len(points))
        ]
        data = np.array(data)

        y = [
            (1. if mouseButtons[i] == 1 else (-1.))
            for i in range(len(points))
        ]
        y = np.array(y)

        classifier.fit(data, y)
</pre>
Для определения класса точки <i>p</i>
можно использовать два метода классификатора:<br/>
1) метод classifier.predict(x) возвращает 1 для первого
класса и -1 для второго;<br/>
2) метод decision_function(x) возвращает значение, пропорциональное
расстоянию со знаком от точки <i>x</i> до разделяющей гиперплоскости.
Для более точного рисования линии уровня естественно использовать
именно этот метод.
<pre>
def classifierValue(p):
    x = np.array([[p.x, p.y]])
    # return classifier.predict(x)
    return classifier.decision_function(x)
</pre>
</p>

<p>
Используя значения, возвращаемые классификатором для точек плоскости,
программа рисует линию нулевого уровня этой функции, заданную
уравнением
<div class="display">
    classifierValue(p) = 0.
</div>
</p>

<h4>Пример применения ядрового метода опорных векторов
    в среде Jupyter-Lab</h4>

<p>
В среде Jupyter-Lab мы сначала генерируем на плоскости случайные точки двух
классов так, чтобы их невозможно было разделить прямой линией.
Затем мы применяем ядровый метод опорных векторов с Гауссовским ядром
"rbf" (Radial Basis Function) и рисуем линию, которая разделяет
два класса. Вот код программы (в среде Jupyter-Lab):
<pre>
# Kernel Support Vector Machine Method

from scipy.optimize import minimize
import numpy as np
import random
from math import sin, cos
import matplotlib.pyplot as plt
from skimage import measure

from sklearn.svm import SVC

get_ipython().run_line_magic('matplotlib', 'inline')
plt.axes(aspect="equal")

m1 = 100
class1 = [ np.array([
    random.normalvariate(1., 1.5), random.normalvariate(1., 0.5)
]) for i in range(m1) ]

m2 = m1
angle1 = -np.pi*2/3
angle2 = np.pi*2/3
ex = np.array([1., 0.]); ey = np.array([0., 1.])
class2 = []
for i in range(m2):
    phi = random.normalvariate(0., 1.)
    r = random.normalvariate(5., 0.5)
    p = ex*cos(phi)*r + ey*sin(phi)*r
    class2.append(p.copy())
    
x = class1 + class2
x = np.array(x)
y = [1.]*len(class1) + [-1.]*len(class2)
y = np.array(y)
m = len(x)
perm = np.random.permutation(m)
x = x[perm]
y = y[perm]

plt.scatter(
    [c[0] for c in x], [c[1] for c in x],
    color=[ "r" if yy > 0. else "g" for yy in y ]
)

degree = 2
C = 2.    # Hyperparameter

# classifier = SVC(C=C, kernel="poly", degree=degree)
classifier = SVC(C=C, kernel="rbf")
classifier.fit(x, y)

def classifierValue(x):
    xx = np.array([  [x[0], x[1]]  ])
    # return classifier.predict(xx)
    return classifier.decision_function(xx)

# Draw the separating line
xmin = min([xx[0] for xx in x]) - 1.
xmax = max([xx[0] for xx in x]) + 1.
ymin = min([xx[1] for xx in x]) - 1.
ymax = max([xx[1] for xx in x]) + 1.
steps = 100

def xcoord(j):
    dx = (xmax - xmin)/steps
    return xmin + j*dx
def ycoord(i):
    dy = (ymax - ymin)/steps
    return ymin + i*dy

# a is a matrix of dimension (steps, steps)
a = np.array([[0.]*steps for iy in range(steps)])
for i in range(steps):
    for j in range(steps):
        xx = np.array([xcoord(j), ycoord(i)])
        a[i, j] = classifierValue(xx)
nullContours = measure.find_contours(a, 0.)
for c in nullContours:
    plt.plot(
        [xcoord(cc[1]) for cc in c], 
        [ycoord(cc[0]) for cc in c],
        color="blue"
    )
</pre>
</p>

<p>
Вот результат работы этой программы (запущенной в среде Jupyter-Lab):<br/>
<img src="svmKernel_out.png"><br/>
Исходный код программы:
"<a href="svmKernel.ipynb">svmKernel.ipynb</a>".
</p>

<a name="HW_KernelSVM">
<h4>Домашнее задание</h4>

<p>
В задании 2 варианта. Студенты с нечетными номерами по журналу
делают вариант 1, с четными &mdash; вариант 2. В обоих вариантах
надо изменить оконную программу
"<a href="svm.py">svm.py</a>" (полный архив всех исходных файлов
"<a href="svm.zip">svm.zip</a>"), в которой реализован классический
линейный метод опорных векторов:<br/>
<img src="../MasterAI/SVM0.png"/>
</p>

<ol>
<li>
Переделать программу
"<a href="svm.py">svm.py</a>", в которой реализован
линейный метод опорных векторов. 
Надо дополнить признаки объектов
всеми мономами (произведениями) степени &le; <i>d</i> от исходных признаков,
число <i>d</i> должно задаваться слайдером. Например, при <i>d</i>=2 мы
вместо точки 
<div class="display">
<i>x</i> = (<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>) &isin; <b>R</b><sup>2</sup>
</div>
используем "расширенную" точку
<div class="display">
<i>x</i>' = (1, <i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>,
<i>x</i><sub>0</sub><sup>2</sup>,
<i>x</i><sub>0</sub><i>x</i><sub>1</sub>,
<i>x</i><sub>1</sub><sup>2</sup>) &isin; <b>R</b><sup>6</sup>,
</div>
при d=3 получится 10-мерное пространство и т.д.
Линейный классификатор вычисляется для расширенного пространства.
Программа должна нарисовать линию, разделяющую точки двух классов.
</li>

<li>
Переделать программу "<a href="svm.py">svm.py</a>",
в которой реализован классический
линейный метод опорных векторов. Модифицированная программа
должна использовать ядровый метод опорных векторов, реализованный
в стандартных модулях Питона в виде класса SVC:
<pre>
from sklearn.svm import SVC
</pre>
Программа должна применить классификатор SVC и нарисовать линию,
разделяющую точки двух классов. В программе должна быть реализована
возможность выбора ядра из двух вариантов: "rbf" (Гауссовское ядро),
"poly" (полиномиальное ядро). В случае полиномиального ядра степень
полинома должна задаваться с помощью слайдера.
</li>
</ol>
</a>

<hr/>

<div class="inactive">
<i>Из программы прошлого года.</i>

<h3>
1.6. Синтаксический разбор.
Реализация сканера с помощью регулярных выражений,
рекурсивная реализация парсера
</h3>

<ul>
<li>
     Проект "Компилятор формул"
     <a href="lparser.py">lparser.py</a>:<br/>
     компилятор формул в обратную польскую запись и стековый вычислитель,
     реализованный в виде класса Parser.
     Для лексического анализа используется модуль re 
     (сокращение от <b>r</b>egular <b>e</b>xpressions), реализующий работу
     с регулярными выражениями. Синтаксический анилиз использует
     алгоритм рекурсивного разбора LL(1).
</li>
<li>
    Проект "Рисование графика функции, заданной в текстовом окне":
    <a href="plotFunction.zip">plotFunction.zip</a><br/>
    <img src="plotFunction.png" /><br/>
    Архив
    <a href="plotFunction.zip">plotFunction.zip</a>
    содержит файлы:
    <ul>
    <li>
        "<a href="lparser.py">lparser.py</a>"
        компилятор формул в обратную польскую запись и стековый вычислитель,
        (class Parser);
    </li>
    <li>
        "<a href="plotFunction.py">plotFunction.py</a>"
        графическая программа, рисующая график функции, которая
        вычисляется по ее текстовой записи с помощью компилятора формул;
    </li>
    <li>
        "<a href="R2Graph.py">R2Graph.py</a>"
        модуль R2Graph, реализующий классы вектор R2Vector 
        и точка R2Point на плоскости, который используются в любых
        геометрических и графических задачах.
    </li>
    </ul>
</li>
</div>

<!--
<h4>
Задачи на тему "Синтаксический разбор"
</h4>

<p>
Во всех задачах надо внести изменение в проект
"<a href="plotFunction.zip">plotFunction.zip</a>"
(в один или в оба файла
"<a href="lparser.py">lparser.py</a>" и
"<a href="plotFunction.py">plotFunction.py</a>").
Результатом должна быть графическая программа, рисующая графики
функций.
</p>

<p>
Студент должен сделать ту задачу, номер которой совпадает по модулю 4
с его номером в журнале.
</p>

<ol>
<li>
     Добавить в язык формул возможность использовать унарный минус
     (операцию изменения знака), например, "sin(-<i>x</i>)*2".
     Унарный минус имеет приоритет, более высокий, чем умножение или
     деление, но ниже, чем операция возведения в степень.
</li>
<li>
     Добавить в язык формул возможность использовать стандартные функции
     от нескольких аргументов, например "4*atan2(<i>x</i>-1, 1 + <i>x</i>^2)".
</li>
<li>
     Нарисовать график функции от двух переменных 
     <i>f</i>(<i>x</i>, <i>y</i>) (изобразить, как трансформируется
     координатная сетка на плоскости (<i>x</i>, <i>y</i>) при применении к ней
     отображения 
     <i>F</i>:(<i>x</i>, <i>y</i>, 0) -&gt; 
         (<i>x</i>, <i>y</i>, <i>f</i>(<i>x</i>, <i>y</i>)).<br/>
     <img src="plot2DFunction.png" />

    <p>
    <i>Указание</i>.
    Используем <i>кабинетную проекцию</i>, в которой базисные векторы
    <i>e</i><sub><i>x</i></sub>, <i>e</i><sub><i>y</i></sub>, 
    <i>e</i><sub><i>z</i></sub>
    пространства <b>R</b><sup>3</sup>
    отображаются на векторы плоскости <b>R</b><sup>2</sup>:
    <div class="display">
        <i>e</i><sub><i>x</i></sub> &rightarrow; (1, 0)<br/>
        <i>e</i><sub><i>y</i></sub> &rightarrow; (&Sqrt;2/4, &Sqrt;2/4)<br/>
        <i>e</i><sub><i>z</i></sub> &rightarrow; (0, 1)<br/>
    </div>
    Поверхность графика функции разбивается на четырехугольники c шагом
    <i>dx</i>, <i>dy</i>; 
    эти четырехугольники рисуются в порядке уменьшения <i>y</i> так, чтобы
    более близкий четырехугольник закрашивал изображенные раньше
    четырехугольники, расположенные дальше от зрителя.
    </p>

    <p>
    Для закрашивания четырехугольника следует использовать метод
    create_polygon класса Canvas:
<pre>
        quad = []
        quad.append(map(map3D(xx0, yy0, z00)))
        quad.append(map(map3D(xx1, yy0, z10)))
        quad.append(map(map3D(xx1, yy1, z11)))
        quad.append(map(map3D(xx0, yy1, z01)))
        drawArea.create_polygon(
            quad, fill = "lightGray", outline="blue"
        )
</pre>
    Здесь функция map3D отображает точку трехмерного пространства 
    <b>R</b><sup>3</sup> на точку плоскости <b>R</b><sup>2</sup>,
    т.е. объект типа R2Point, используя кабинетную
    проекцию; функция map переводит точку в математических координатах
    в пиксельные координаты.
    </p>
</li>
<li>
    Переделать проект
    "<a href="plotFunction.zip">plotFunction.zip</a>", чтобы можно было рисовать
    сразу две функции в одном окне. 
    Графики функций рисуются разными цветами.
    Тексты обеих функций задаются в двух текстовых
    полях (окнах типа tkinter.Entry):<br/>
    <img src="plotFunction2.png"/><br/>
    <i>Указание</i>. Следует создать два экземпляра объектов типа Parser:
    первый объект вычисляет первую функцию, второй &mdash; вторую функцию.
    <pre>
from tkinter import *
import math
from R2Graph import *
import lparser

parser1 = lparser.Parser()
function1Defined = False

parser2 = lparser.Parser()
function2Defined = False

def func1(x):
    if function1Defined:
        return parser1.evaluate(x = x)
    else:
        return 0.

def func2(x):
    if function2Defined:
        return parser2.evaluate(x = x)
    else:
        return 0.
</pre>
    Аналогично надо создать два текстовых поля, в которых задаются тексты двух функций, 
    два поля для сообщений об ошибках компиляции и т.д.
</li>
</ol>

-->

<hr/>

<div class="inactive">
<h2>Из программы прошлого года</h2>

<h3>
1.6. Параллельное программирование на языке Python:
     нити и объекты синхронизации
</h3>

<p>
Презентация: 
<a href="Presentation/threads.pdf">Нити и объекты синхронизации</a>
</p>

<h4>Примеры программ</h4>

<ul>
<li>
    Простейший пример на использование нитей и мьютекса &mdash;
    жеребьевка: <a href="../python/headsTails.py">headsTails.py</a>.
    Программа использует модуль threading.

    <p>
    Запускаются две однотипные нити (объект Thread), 
    первая 10 раз печатает слово
    "Heads", вторая "Tails", в промежутках между печатями
    каждая нить засыпает на случайное время в интервале от
    0.1 до 1 секунды. Выигрывает та нить, которая напечатает
    свое слово последней. Для предотвращения каши на печати
    нити для доступа к консоли используют мьютех (в языке Python
    он называется Lock), захват мьютекса производится методом
    acquire(), освобождение &mdash; release().
    Ожидание завершения нити выполняется с
    помощью метода join() объекта типа Thread.
    </p>
</li>
</ul>

<h4>
Задачи
</h4>

<ol>
<li>
Вычислить определенный интеграл от заданной функции,
разбив отрезок интегрирования на n частей (n небольшое!) и запустив
для каждой части отдельную нить. 
</li>

<li>
Перемножить две квадратные n*n-матрицы, запустив k*k нитей,
где k делит n. Нить с индексами (s,t) вычисляет минор 
матрицы-произведения в строках s*m+1, ..., s*m+m и столбцах
t*m+1, ..., t*m+m, где m = n/k. (Результирующая матрица
разбивается на клетки размера m = n/k, каждая нить вычисляет
одну клетку.)
</li>

<li>
Привести матрицу к ступенчатому виду методом Гаусса,
используя параллельную работу со строками матрицы при обнулении
очередного столбца.
</li>
</ol>

<h3>
1.7. Сетевые приложения на языке Python, интерфейс сокетов
</h3>

<h4>Примеры программ </h4>
<ul>
<li>
    Скачать страницу из Internet по протоколу HTTP:
    <a href="../python/httpGet.py">httpGet.py</a>
</li>
<li>
    Пара простейших программ, использующих протокол UDP
    и групповое широковещание (multicast):
    программа <a href="../python/udpSnd.py">udpSnd.py</a>
    раз в секунду посылает дейтаграму по широковещательному
    адресу (224.1.1.22, 1234), которая содержит текущее время
    в текстовом формате. 
    Программа <a href="../python/udpRecv.py">udpRecv.py</a>
    принимает эти дейтаграмы и распечатывает их на консоли.
</li>
</ul>
</div>

<hr/>

<h2>
Тема 2. Система компьютерной математики SageMath
</h2>

<h3>
2.1. Задачи по геометрии
</h3>

<p>
Решения всех задач должны быть оформлены как функции
на языке Sage (аналогичны функциям в языке Python).
Например, в задаче "Нарисовать треугольник, вписанную
окружность и точку Жергона" решение оформляется в виде функции,
на вход которой подаются 3 точки и которая возвращает графический
объект.
</p>

<p>
<b>Пример решения задачи:</b>
нарисовать треугольник, вписанную и описанную вокруг него окружности,
а также изобразить процесс их построения &mdash;
биссектрисы и серединные перпендикуляры.<br/>
Код sage-программы: "<a href="geometry.sage">geometry.sage</a>".<br/>
Пример использования функции:
<pre>
    <font color="blue">sage:</font> load("geometry.sage")
    <font color="blue">sage:</font> a = vector([0, 0])
    <font color="blue">sage:</font> b = vector([5, 1])
    <font color="blue">sage:</font> c = vector([3, 5])
    <font color="blue">sage:</font> drawTriangle(a, b, c)
</pre>
<img src="triangleCircles.png" />

<h4>Список задач</h4>

<ol>
<li>
Нарисовать треугольник, вписанную окружность и точку Жергона.<br/>
<img src="GergonnePoint.png" />
</li>

<li>
Нарисовать треугольник, три внешне вписанных окружности и точку Нагеля.<br/>
<img src="NagelPoint.png" />
</li>

<li>
Нарисовать треугольник и точку Лемуана, которая построена как
точка, изогонально сопряженная к точке пересечения медиан.<br/>
<img src="LemoinePoint.png" />
</li>

<li>
Нарисовать треугольник и точку Ферма-Торичелли (точка, минимизирующая
сумму расстояний до вершин треугольника), изобразив процесс ее
построения.<br/>
<img src="TorricelliPoint.png" />
</li>
</ol>

<div class="inactive">
<i>Из программы прошлого года.</i>

<h3>
2.2. Кубическая интерполяция и построение кубических сплайнов
</h3>

<p>
Рассматривается задача интерполяции, т.е. построения функции
<i>y</i> = <i>f</i>(<i>x</i>)
по заданным значениям в дискретном множестве узлов. Чаще всего
такая функция строится как сплайн, состоящий из кубических многочленов,
причем различаются C<sub>1</sub>-сплайны с непрерывной первой производной
и C<sub>2</sub>-сплайны, у которых непрерывны первая и вторая производные.
</p>

<p>
Построение кубического C<sub>1</sub>-сплайна основано на следующем утверждении.
</p>

<div class="display">
    Пусть заданы два узла интерполяции 
    <i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>,
    значения кубического многочлена
    <i>p</i><sub>0</sub>, <i>p</i><sub>1</sub>
    и значения производной многочлена
    <i>dp</i><sub>0</sub>, <i>dp</i><sub>1</sub>
    в этих узлах.
    Тогда такой многочлен существует и единственен.
</div>

<p>
На следующем рисунке представлен график такого многочлена
для значений
<div class="display">
    <i>x</i><sub>0</sub> = -5, <i>x</i><sub>1</sub> = 6,
    <i>p</i><sub>0</sub> = -4, <i>p</i><sub>1</sub> = 1,
    <i>dp</i><sub>0</sub> = 3, <i>dp</i><sub>1</sub> = 1.<br/>
</div>
<img src="cubicPol.png"/>
</p>

<p>
Можно самостоятельно вывести формулы для коэффициентов этого
многочлена &mdash; например, выписав систему из 4-х уравнений и решив ее,
либо каким-нибудь другим, более умным способом. Но в любом случае
выражения получатся громоздкими, так что лучше предоставить эти вычисления
SageMath. Сначала зададим переменные
<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>,
<i>p</i><sub>0</sub>, <i>p</i><sub>1</sub>,
<i>dp</i><sub>0</sub>, <i>dp</i><sub>1</sub>, а также коэффициенты
многочлена по возрастанию степеней
<i>a</i><sub>0</sub>, <i>a</i><sub>1</sub>,
<i>a</i><sub>2</sub>, <i>a</i><sub>3</sub>:
</p>
<pre>
    var("x0 x1 p0 p1 dp0 dp1")
    var("a0 a1 a2 a3")
</pre>
<p>
Зададим многочлен и его производную по <i>x</i>:
</p>
<pre>
    p(x) = a0 + a1*x + a2*x^2 + a3*x^3
    dp(x) = derivative(p(x), x)
</pre>
<p>
Выпишем 4 уравнения:
</p>
<pre>
    eq0 = (p(x = x0) == p0)
    eq1 = (p(x = x1) == p1)
    eq2 = (dp(x = x0) == dp0)
    eq3 = (dp(x = x1) == dp1)
</pre>
<p>
И теперь решим систему уравнений относительно неизвестных
<i>a</i><sub>0</sub>, <i>a</i><sub>1</sub>,
<i>a</i><sub>2</sub>, <i>a</i><sub>3</sub>,
воспользовавшись функцией solve:
</p>
<pre>
    res = solve([eq0, eq1, eq2, eq3], [a0, a1, a2, a3])
</pre>
<p>
Результатом является список решений, в данном случае состоящий
из одного элемента (т.е. решение единственно). Решение &mdash;
это список из 4-х уравнений, каждое из них имеет вид
<div class="display">
    a<sub><i>i</i></sub> = выражение от переменных
    <i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>,
    <i>p</i><sub>0</sub>, <i>p</i><sub>1</sub>,
    <i>dp</i><sub>0</sub>, <i>dp</i><sub>1</sub>.
</div>
Например, напечатаем уравнение для свободного члена <i>a</i><sub>0</sub>
многочлена:
<pre>
    <font color="blue">sage:</font> res[0][0]
    a0 == -((dp1*x1 - p1)*x0^3 + p0*x1^3 + ((dp0 - dp1)*x1^2 + 3*p1*x1)*x0^2 -
    (dp0*x1^3 + 3*p0*x1^2)*x0)/(x0^3 - 3*x0^2*x1 + 3*x0*x1^2 - x1^3)
</pre>
Если нам нужно выражение для свободного члена, а не уравнение,
то можно воспользоваться методом rhs(), который возвращает
правую часть уравнения (от слов right hand side):
<pre>
    <font color="blue">sage:</font> res[0][0].rhs()
    -((dp1*x1 - p1)*x0^3 + p0*x1^3 + ((dp0 - dp1)*x1^2 + 3*p1*x1)*x0^2 -
    (dp0*x1^3 + 3*p0*x1^2)*x0)/(x0^3 - 3*x0^2*x1 + 3*x0*x1^2 - x1^3)
</pre>
Получив выражения для коэффициентов многочлена интерполяции,
нетрудно нарисовать его график. Соответствующая программа
содержится в файле
"<a href="cubicPol.sage">cubicPol.sage</a>". Вот
пример ее выполнения:
<pre>
<font color="blue">sage:</font> load("cubicPol.sage")
<font color="blue">sage:</font> drawCubicInterpolation(xx0=-5, xx1=6, y0=-4, y1=1, dy0=3, dy1=1)
</pre>
<img src="cubicPolSage.png"/>
</p>

<h4>Задачи на построение кубического сплайна</h4>

<p>
В задачах надо написать <i>функцию</i> (в смысле Python'а)
с именем <i>splineC1</i> или <i>splineC2</i>,
на вход которой передается список пар. Каждая пара содержит
координаты (<i>x</i><sub><i>i</i></sub>, <i>y</i><sub><i>i</i></sub>)
<i>i</i>-го узла интерполяции, при этом координаты <i>x</i>
идут в строго возрастающем порядке. Функция должна
построить кубический <i>C</i><sub>1</sub> или <i>С</i><sub>2</sub>-сплайн 
(с непрерывными только первыми производными или
как первыми, так и вторыми производными). 
Пример использования функции:
<pre>
    s = splineC1([(-7,-4), (-5,-1), (-3,-2), (-1,2),
                 (1,3), (3,1), (5,3), (7,-1)])
    show(s, aspect_ratio=1)
</pre>
<img src="splineC1Sage.png" />
<!-- (этот <i>C</i><sub>1</sub>-сплайн показан на первой картинке ниже). -->
</p>

<p>
При построении
<i>C</i><sub>1</sub>-сплайна надо дополнительно задать производные
в каждом узле, они определяются как полусумма значений тангенсов
наклона звеньев ломаной слева и справа от узла. 
В начальном и конечном узлах производная задается как тангенс
угла наклона звена ломаной, выходящего из этого узла.
</p>

<p>
При построении
<i>C</i><sub>2</sub>-сплайна</i> решается система линейных уравнений,
где неизвестными являются коэффициенты кубических многочленов,
составляющих сегменты сплайна. Пусть дан <i>n</i>+1 узел:
<div class="display">
    (<i>x</i><sub>0</sub>, <i>y</i><sub>0</sub>),
    (<i>x</i><sub>1</sub>, <i>y</i><sub>1</sub>), ...,
    (<i>x</i><sub><i>n</i></sub>, <i>y</i><sub><i>n</i></sub>).
</div>
В каждом из промежуточных узлов (<i>x</i><sub>i</sub>, <i>y</i><sub>i</sub>),
0&lt; <i>i</i> &lt; <i>n</i>, мы имеем 4 уравнения:
<div class="display">
1) левый сегмент сплайна принимает значение <i>y</i><sub><i>i</i></sub>,<br/>
2) правый сегмент сплайна принимает значение <i>y</i><sub><i>i</i></sub>,<br/>
3) производные левого и правого сегментов сплайна равны между собой,<br/>
4) вторые производные левого и правого сегментов сплайна равны между собой.
</div>
В начальном и конечном узлах выписываются по 2 уравнения,
для начального узла:
<div class="display">
1) значение начального сегмента в точке <i>x</i><sub>0</sub>
равно <i>y</i><sub>0</sub>,<br/>
2) значение второй производной начального сегмента
сплайна в точке <i>x</i><sub>0</sub> равно нулю,
</div>
и аналогичные уравнения для конечного узла.
Общее число уравнений получается равным
<div class="display">
    2 + 4(<i>n</i> - 1) + 2 = 4<i>n</i>,
</div>
что в точности равно числу неизвестных (для <i>n</i>+1 узла
имеем <i>n</i> сегментов сплайна, каждый сегмент является кубическим
многочленом с 4 коэффициентами, всего коэффициентов 4<i>n</i>).
Если выписать уравнения в порядке следования узлов, то
матрица этой системы получится ленточной, следовательно,
система уравнений решается методом Гаусса за время <i>O</i>(<i>n</i>),
т.е. практически мгновенно. (Специально рассматривать случай системы
с ленточной матрицей не нужно, SageMath все делает самостоятельно.)
</p>

<p>
Файл "<a href="splineC2_3Nodes.sage">splineC2_3Nodes.sage</a>"
содержит решение этой задачи для случая трех узлов. Вот пример работы
программы:
<pre>
    sage: load ("splineC2_3Nodes.sage")
    sage: splineC2([(-1, -1), (0, 1), (2, 0)])
    Matrix of the system:
    [ 1 -1  1 -1  0  0  0  0]
    [ 0  0  2 -6  0  0  0  0]
    [ 1  0  0  0  0  0  0  0]
    [ 0  0  0  0  1  0  0  0]
    [ 0  1  0  0  0 -1  0  0]
    [ 0  0  2  0  0  0 -2  0]
    [ 0  0  0  0  1  2  4  8]
    [ 0  0  0  0  0  0  2 12]
    Column of free terms: (-1, 0, 1, 1, 0, 0, 0, 0)
    Solution of the system: (1, 7/6, -5/4, -5/12, 1, 7/6, -5/4, 5/24)
    Resulting spline: [(1, 7/6, -5/4, -5/12), (1, 7/6, -5/4, 5/24)]
    Launched png viewer for Graphics object consisting of 5 graphics primitives
</pre>
<img src="splineC2_3Nodes.png" />
</p>

<h4>Список задач</h4>

<p>
Студенты с нечетными номерами по журналу делают первую задачу,
с четными &mdash; вторую.
</p>

<ol>
<li>
    Построить <i>C</i><sub>1</sub>-сплайн.<br/>
    <img src="splineC1Sage.png" />
</li>
<li>
    Построить <i>C</i><sub>2</sub>-сплайн.<br/>
    <img src="splineC2Sage.png" />
</li>
</ol>

</div>

<h3>
2.3. Коммутативная алгебра:
системы алгебраических уравнений и базисы Гребнера
</h3>

<p>
Рассматриваются кольца многочленов от нескольких переменных над полем
комплексных чисел,
конечные наборы многочленов в них, порождаемые ими идеалы и 
аффинные многообразия.
Предполагаются известными теоремы Гильберта о конечности базисов и
о нулях, а также теория базисов Гребнера. Рекомендуется книга
<div class="display">
    <a href="https://www.mccme.ru/free-books/dubna/arjantsev.pdf">И.В.Аржанцев.<br/>
    Базисы Гребнера и системы
    алгебраических уравнений</a>,
</div>
<br/>
а также пособие по математическому практикуму
для группы алгебры
<div class="display">
    <a href="http://halgebra.math.msu.su/practicum/practicum-book.pdf">А.И.Зобнин, О.В.Соколова.<br/>
    Компьютерная алгебра в системе Sage</a>.
</div>
</p>

<a href="commalg.pdf">Презентация к лекции по коммутативной алгебре</a>

<h4>
Пример решения задачи: определить принадлежность многочлена
от многих переменных к радикалу идеала <i>I</i>
</h4>

<p>
Рассматривается алгебра многочленов от нескольких переменных
над полем комплексных чисел. В SageMath кольцо многочленов задается
предложением
<pre>
    R = PolynomialRing(CC, "x, y, z", order="lex")
</pre>
Здесь <i>С</i><i>С</i> &mdash; поле комплексных чисел, 
"<i>x</i>, <i>y</i>, <i>z</i>" &mdash; названия
трех переменных; параметр order="lex" задает чисто лексикографический
порядок на мономах. Многочлены (т.е. элементы кольца <i>R</i>),
соответствующие переменным <i>x</i>, <i>y</i>, <i>z</i>, можно задать
с помощью следующих предложений:
<pre>
    x = R.gen(0); y = R.gen(1); z = R.gen(2)
</pre>
или в одной команде (учитывая особенности языка Python):
<pre>
    x, y, z = R.gens()
</pre>
Можно также задать многочлены-образующие кольца непосредственно в
предложении, определяющем кольцо:
<pre>
    R.&lt;x0, x1, x2&gt; = PolynomialRing(CC, 3, "x", ordel="lex")
</pre>
Здесь определено кольцо многочленов над полем комплексных чисел от 3-х
переменных, префикс названия переменных "<i>x</i>".
</p>

<p>
Радикалом идеала <i>I</i> называется множество многочленов,
степени которых лежат в идеале <i>I</i>:
<div class="display">
    Rad(<i>I</i>) = { <i>f</i>: <i>f</i><sup><i>m</i></sup>&isin;<i>I</i> для
                      некоторого целого <i>m</i> &ge; 0 }
</div>
По теореме Гильберта о нулях, радикал идеала <i>I</i> совпадает
с множеством многочленов, которые обращаются в 0 на всех корнях идеала
<i>I</i> (т.е. на аффинном алгебраическом многообразии, заданном
идеалом). Из доказательства теоремы Гильберта о нулях следует, что
<i>f</i> &isin; Rad(<i>I</i>) тогда и только тогда, когда 
следующий идеал содержит единицу (т.е. тривиален):
<div class="display">
    1 &isin; Ideal{ <i>I</i>, (1 - <i>y</i>&middot;<i>f</i>) }
</div>
Здесь мы добавили новую
переменную <i>y</i> к переменным <i>x</i><sub><i>i</i></sub>, от которых
зависят многочлены из идеала <i>I</i>.
</p>

<p>
Реализуем в SageMath функцию, проверяющую, лежит ли многочлен <i>f</i>
в радикале идеала <i>I</i>, заданного многочленами из
списка s:
<pre>
def inRadical(f, s):
    sum = f
    for g in s:
        sum += g
    R = parent(sum)
    variables = [ str(v) for v in R.gens() ]
    variables.append("yyy")
    H = PolynomialRing(CC, variables)
    yyy = H.gens()[-1]
    s1 =  s.copy()
    s1.append(1 - yyy*f)
    J = ideal(s1).groebner_basis()
    return J == [1.] 
</pre>
Программа записана в файле "<a href="radical.sage">radical.sage</a>".
</p>

<p>
Пример применения этой функции:
<pre>
sage: load("radical.sage")
sage: R.<x, y, z> = PolynomialRing(CC, "x, y, z")
sage: g = (x^2 + y^2 - 1)^2
sage: h = x^2 + y^2 + z^2 + 1
sage: f = z^2 + 2
sage: f in ideal(g, h)
False
sage: f^2 in ideal(g, h)
True
sage: inRadical(f, [g, h])
True
sage: inRadical(f + 1, [g, h])
False
</pre>
</p>

<h4>
Домашнее задание
</h4>

<p>
Требуется решить одну задачу из списка: номер 1 для студентов с
нечетным номером по журналу, номер 2 с четным. Надо реализовать
функцию на языке <i>Sage</i>, которая возвращает значение
True или False. Набор многочленов передается функции как список.
</p>

<h4>Список задач</h4>

<ol>
<li>
Даны два конечных набора многочленов. Определить, задают ли они
одно и то же аффинное многообразие.
</li>

<!--
<li>
Проверить совместимость системы алгебраических уравнений
от нескольких переменных.
</li>
-->

<li>
Выяснить, имеет ли система алгебраических уравнений лишь конечное
число решений (при этом хотя бы одно решение должно существовать).
</li>

</ol>

<hr/>

<a name="Sem2_2020">
<h2>
Весенний семестр прошлого года (весна 2020)
</h2>
</a>

<a href="MagList2019-20.html">Журнал группы магистратуры 1 курса,
2019-20 уч. год</a>.

<h4>Видео лекций (весна 2020)</h4>
<ul>
<p>
Лекция 25 марта 2020:
<a href="Presentation/threads.pdf">Нити и объекты синхронизации</a>
</p>

<p>
Лекция 1 апреля 2020:
не состоится ввиду объявленных каникул до 5 апреля.
</p>

<p>
Лекция 8 апреля 2020:
<a href="PythonGraphics.html">Графика на языке Python</a>
</p>

<p>
Лекция 15 апреля 2020:
<ul>
<li>
     Графика на языке Python: захват и перемещение элементов картинки
     мышью.<br/>
     Введение в SageMath (начало).
     <a href="https://vimeo.com/408294303">Видео первой части лекции</a>.
</li>
<li>
     Введение в систему компьютерной математики SageMath.<br/>
     <a href="https://vimeo.com/408306478">Видео второй части лекции</a>.
</li>
</ul>
</p>

<p>
Лекция 22 апреля 2020: SageMath, построение кубического сплайна.<br/>
<a href="https://vimeo.com/410844648">Видео</a>.
</p>

<p>
Лекция 6 мая 2020: Базисы Гр&#1105;бнера в кольцах многочленов
от нескольких переменных. <br/>
<a href="https://vimeo.com/416271653">Видео</a>,
<a href="commalg.pdf">презентация</a>.
</p>

<p>
Семинар 13 мая 2020: решения задач на базисы Гр&#1105;бнера в
кольцах многочленов, сплайны и др.<br/>
<a href="https://vimeo.com/417963304">Видео</a>.
</p>
</ul>
<hr/>

</td></tr>
</table>

</body>
</html>
